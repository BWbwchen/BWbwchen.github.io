<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Epoll study | Bo-Wei Chen&#39;s Blog</title>

<meta name="keywords" content="epoll, tcp" />
<meta name="description" content="let&rsquo;s study about epoll, blocking and non-blocking">
<meta name="author" content="Bo-Wei Chen">
<link rel="canonical" href="https://BWbwchen.github.io/posts/http_server_in_go/" />
<link href="/assets/css/stylesheet.min.16158c8087e20777fae960c355760affd58290b604a39d72053581389a2a6bdb.css" integrity="sha256-FhWMgIfiB3f66WDDVXYK/9WCkLYEo51yBTWBOJoqa9s=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://BWbwchen.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://BWbwchen.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://BWbwchen.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://BWbwchen.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://BWbwchen.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />


<meta property="og:title" content="Epoll study" />
<meta property="og:description" content="let&rsquo;s study about epoll, blocking and non-blocking" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://BWbwchen.github.io/posts/http_server_in_go/" />
<meta property="article:published_time" content="2021-08-13T16:24:04+08:00" />
<meta property="article:modified_time" content="2021-08-13T16:24:04+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Epoll study"/>
<meta name="twitter:description" content="let&rsquo;s study about epoll, blocking and non-blocking"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Epoll study",
  "name": "Epoll study",
  "description": "let\u0026amp;rsquo;s study about epoll, blocking and non-blocking",
  "keywords": [
    "epoll", "tcp"
  ],
  "articleBody": "Blocking and Non-Blocking When you send a request to server. Server will prepare some data for you (I/O operations). When you wait for data preparation, your program :\n hang up the thread until the server finished the preparation and send response to you. (Blocking) will get response immediately, but you probably got an error, if server hasn’t finished the data preparation. Your program need to polling the server and checking error code of each request. But you are not blocked ! (Non-Blocking)  Synchronous and Asynchronous When you send a request to server. Server will prepare some data for you (I/O operations). When you wait for data preparation, your program :\n hand up the thread until the server finished the preparation and send treponse to you. (Synchronous) will get response immediately, but server will run your request in “backgroung”. When server finished your request, it will notify you, or run the callback function. (Asynchronous)  Non-Blocking I/O in C Normally, you can’t read or write directly to disk files. They usually do it via the kernel buffer cache as a proxy. But if you want to read or write directly, use O_SYNC flag when opening the disk file.\nYou can put any file descriptor in the nonblocking mode, just setting the no-delay flag O_NONBLOCK, which is an I/O operating mode, when opening the file.\nReadiness of Descriptors We called it “ready”. When a file descriptor can perform an I/O operation without blocking, such as the arrival of new input or sock connection establishment etc. There are 2 ways to find out the readiness of descriptors.\nLevel Triggered (select, poll, epoll) (when the condition is met) At any time, we “try to”(or poll for) perform an I/O operation on an non-blocking descriptor. If the I/O operation blocks, the system call returns an error. If the I/O operation ready, we can actually perform the entire I/O operation or just do nothing.\nEdge Triggered (Asynchronous) (when the status changed) When the I/O operation is ready, it will notify the process or “PUSH” to the process. The process can attempt to perform the maximum operation it possibly can every time it get a descriptor readiness notification, or it will need to wait until next notification arrival.\nBut even with both 2 non-blocking methods, an extremely large read or write call has the potential to block.\nSelect level triggered mechanism.\nint select( int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout ); Select monitors 3 independent sets of descriptors.\n readfds, check if a read will not block writedfs, check if a write will not block exceptfds, monitored for exceptional conditions.  Poll But what if you want not just read, write or exceptional conditions ? Use poll ! we pass in a set of descriptors each marked event that it needs to track.\nint poll(struct pollfd *fds, nfds_t nfds, int timeout); struct pollfd { int fd; /* file descriptor */ short events; /* requested events */ short revents; /* returned events */ }; Epoll (event poll) Epoll instance is a kernel data structure. It allows for a process to monotor multiplex I/O on mltiple descriptors. You have 3 system call to control epoll instance :\nepoll_create() #include  int epoll_create(int size); The size augrument, which is the number of descriptors, is ignored since Linux 2.6.8.\n#include  int epoll_create1(int flags); flags can only be either 0 or EPOLL_COLEXEC.\n flags is 0, it is the same as epoll_create(). flags is EPOLL_COLEXEC, it will set close-on-exec flag on the new file descriptor.  epoll_ctl() #include  int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); It preformed op on target fd in epfd with event\nop  EPOLL_CTL_ADD EPOLL_CTL_MOD EPOLL_CTL_DEL  events typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; events is just a bitmask that indicates which events fd is being monitored for. For example:\nEPOLLIN : The associated file is available for read operations. EPOLLOUT : The associated file is available for write operations. If you want to perform multiple events, just OR-ing them.\nepoll_wait() #include int epoll_wait(int epfd, struct epoll_event *eventlist, int maxevents, int timeout); blocks until any descriptor being monitored become ready for I/O\nThe bowels of epoll In process Let’s first learn how the descriptor works. I create a file descriptor in process A, I will get a file descriptor. The system will store the descriptor and it’s file pointer in a table in my process A. Every entry in this table has 2 fields :\n descriptor flags. file pointer, point to an underlying kernel open file table. indexed by descriptor.  In kernel Each file pointer point to an entry in kernel open file table. each entry in kernel open file table has 3 fields :\n file offset status flags inode pointer.  In filesystem Then each inode pointer point to an entry in filesystem inode table. each entry in filesystem inode table has some fields :\n file type. file locks. etc.  How epoll works process A call epoll_create() to create an epoll instance. The system will create an entry in kernel open file table, and it point to an entry in inode table. secondly, process A call epoll_ctl() to add a file descriptor fd0 to the epoll instance’s interset list. The system will point the fd0 in epoll instance to fd0 in kernel open file table (NOTICE: the kernel open file table entry is shared by referenced descriptor !!)\nexample Consider the situation above, process A fork process B without close-on-exec, process B will have table as same as process B. for example, process A have fd0 and fork process B, it have a descriptor fd1. But fd0 and fd1 point to the same underlying kernel open file table entry.\nFork epoll So same case, but the fd0 and fd1 in the above case is epoll descriptor. process A call epoll_wait(), after a moment it got notifications. But at the same time, process B will also got the notifications !!!\nSo we can say once a file descriptor is registered by a process with the epoll instance, it will continue getting notifications about events on the descriptor even if it closes the descriptors as long as the underlying open file descriptor is still referenced by at least one descriptor.\nPerformance Select and poll are O(N) (or O(number of descriptors being monitored)), but epoll is O(1) (or O(number of events that have occurred)). Because every time the descriptor become ready, kernel will add it into the ready list in epoll instance. Once process call epoll_wait(), just return the ready list.\n",
  "wordCount" : "1107",
  "inLanguage": "en",
  "datePublished": "2021-08-13T16:24:04+08:00",
  "dateModified": "2021-08-13T16:24:04+08:00",
  "author":{
    "@type": "Person",
    "name": "Bo-Wei Chen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://BWbwchen.github.io/posts/http_server_in_go/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Bo-Wei Chen's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://BWbwchen.github.io/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://BWbwchen.github.io/" accesskey="h" title="Bo-Wei Chen&#39;s Blog (Alt + H)">Bo-Wei Chen&#39;s Blog</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://BWbwchen.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://BWbwchen.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://BWbwchen.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://BWbwchen.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Epoll study
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">

August 13, 2021&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Bo-Wei Chen

    </div>
  </header> 

  <div class="toc">
    <details >
      <summary accesskey="c" title="(Alt + C)">
        <div class="details">Table of Contents</div>
      </summary>
      <div class="inner"><ul><li>
        <a href="#blocking-and-non-blocking" aria-label="Blocking and Non-Blocking">Blocking and Non-Blocking</a></li><li>
        <a href="#synchronous-and-asynchronous" aria-label="Synchronous and Asynchronous">Synchronous and Asynchronous</a><ul>
            <li>
        <a href="#non-blocking-io-in-c" aria-label="Non-Blocking I/O in C">Non-Blocking I/O in C</a></li><li>
        <a href="#readiness-of-descriptors" aria-label="Readiness of Descriptors">Readiness of Descriptors</a><ul>
            <li>
        <a href="#level-triggered-select-poll-epoll-when-the-condition-is-met" aria-label="Level Triggered (select, poll, epoll) (when the condition is met)">Level Triggered (select, poll, epoll) (when the condition is met)</a></li><li>
        <a href="#edge-triggered-asynchronous-when-the-status-changed" aria-label="Edge Triggered (Asynchronous) (when the status changed)">Edge Triggered (Asynchronous) (when the status changed)</a></li><li>
        <a href="#select" aria-label="Select">Select</a></li><li>
        <a href="#poll" aria-label="Poll">Poll</a></li><li>
        <a href="#epoll-event-poll" aria-label="Epoll (event poll)">Epoll (event poll)</a><ul>
            <li>
        <a href="#epoll_create" aria-label="epoll_create()">epoll_create()</a></li><li>
        <a href="#epoll_ctl" aria-label="epoll_ctl()">epoll_ctl()</a><ul>
            <li>
        <a href="#op" aria-label="op">op</a></li><li>
        <a href="#events" aria-label="events">events</a></li></ul>
    </li><li>
        <a href="#epoll_wait" aria-label="epoll_wait()">epoll_wait()</a></li></ul>
    </li></ul>
    </li><li>
        <a href="#the-bowels-of-epoll" aria-label="The bowels of epoll">The bowels of epoll</a><ul>
            <ul>
            <li>
        <a href="#in-process" aria-label="In process">In process</a></li><li>
        <a href="#in-kernel" aria-label="In kernel">In kernel</a></li><li>
        <a href="#in-filesystem" aria-label="In filesystem">In filesystem</a></li></ul>
        <li>
        <a href="#how-epoll-works" aria-label="How epoll works">How epoll works</a><ul>
            <li>
        <a href="#example" aria-label="example">example</a></li><li>
        <a href="#fork-epoll" aria-label="Fork epoll">Fork epoll</a></li></ul>
    </li><li>
        <a href="#performance" aria-label="Performance">Performance</a></li></ul>
</li></ul>
</li></ul>
      </div>
    </details>
  </div>
  <div class="post-content">
<h1 id="blocking-and-non-blocking">Blocking and Non-Blocking<a hidden class="anchor" aria-hidden="true" href="#blocking-and-non-blocking">#</a></h1>
<p>When you send a request to server. Server will prepare some data for you (I/O operations). When you wait for data preparation, your program :</p>
<ol>
<li>hang up the thread until the server finished the preparation and send response to you. (<strong>Blocking</strong>)</li>
<li>will get response immediately, but you probably got an error, if server hasn&rsquo;t finished the data preparation. Your program need to <!-- raw HTML omitted -->polling the server and checking error code of each request<!-- raw HTML omitted -->. But you are not blocked ! (<strong>Non-Blocking</strong>)</li>
</ol>
<h1 id="synchronous-and-asynchronous">Synchronous and Asynchronous<a hidden class="anchor" aria-hidden="true" href="#synchronous-and-asynchronous">#</a></h1>
<p>When you send a request to server. Server will prepare some data for you (I/O operations). When you wait for data preparation, your program :</p>
<ol>
<li>hand up the thread until the server finished the preparation and send treponse to you. (<strong>Synchronous</strong>)</li>
<li>will get response immediately, but server will run your request in &ldquo;backgroung&rdquo;. When server finished your request, it will <!-- raw HTML omitted -->notify you, or run the callback function<!-- raw HTML omitted -->. (<strong>Asynchronous</strong>)</li>
</ol>
<h2 id="non-blocking-io-in-c">Non-Blocking I/O in C<a hidden class="anchor" aria-hidden="true" href="#non-blocking-io-in-c">#</a></h2>
<p>Normally, you can&rsquo;t read or write directly to disk files. They usually do it via the kernel buffer cache as a proxy. But if you want to read or write directly, use <strong>O_SYNC</strong> flag when opening the disk file.</p>
<p>You can put any file descriptor in the nonblocking mode, just setting the no-delay flag <strong>O_NONBLOCK</strong>, which is an I/O operating mode, when opening the file.</p>
<h2 id="readiness-of-descriptors">Readiness of Descriptors<a hidden class="anchor" aria-hidden="true" href="#readiness-of-descriptors">#</a></h2>
<p>We called it &ldquo;ready&rdquo;. When a file descriptor can perform an I/O operation without blocking, such as the arrival of new input or sock connection establishment etc. There are 2 ways to find out the readiness of descriptors.</p>
<h3 id="level-triggered-select-poll-epoll-when-the-condition-is-met">Level Triggered (select, poll, epoll) (when the condition is met)<a hidden class="anchor" aria-hidden="true" href="#level-triggered-select-poll-epoll-when-the-condition-is-met">#</a></h3>
<p>At any time, we &ldquo;try to&rdquo;(or poll for) perform an I/O operation on an non-blocking descriptor. If the I/O operation blocks, the system call returns an error. If the I/O operation ready, we can actually perform the entire I/O operation or just do nothing.</p>
<h3 id="edge-triggered-asynchronous-when-the-status-changed">Edge Triggered (Asynchronous) (when the status changed)<a hidden class="anchor" aria-hidden="true" href="#edge-triggered-asynchronous-when-the-status-changed">#</a></h3>
<p>When the I/O operation is ready, it will notify the process or &ldquo;PUSH&rdquo; to the process. The process can attempt to perform the maximum operation it possibly can every time it get a descriptor readiness notification, or it will need to wait until next notification arrival.</p>
<p>But even with both 2 non-blocking methods, an extremely large read or write call has the potential to block.</p>
<h3 id="select">Select<a hidden class="anchor" aria-hidden="true" href="#select">#</a></h3>
<p>level triggered mechanism.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">select</span>(
	<span style="color:#66d9ef">int</span> nfds, 
	fd_set <span style="color:#f92672">*</span>readfds, 
	fd_set <span style="color:#f92672">*</span>writefds,
	fd_set <span style="color:#f92672">*</span>exceptfds, 
	<span style="color:#66d9ef">struct</span> timeval <span style="color:#f92672">*</span>timeout
);
</code></pre></div><p>Select monitors 3 independent sets of descriptors.</p>
<ol>
<li>readfds, check if a read will not block</li>
<li>writedfs, check if a write will not block</li>
<li>exceptfds, monitored for exceptional conditions.</li>
</ol>
<h3 id="poll">Poll<a hidden class="anchor" aria-hidden="true" href="#poll">#</a></h3>
<p>But what if you want not just read, write or exceptional conditions ? Use poll ! we pass in a set of descriptors each marked event that it needs to track.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">poll</span>(<span style="color:#66d9ef">struct</span> pollfd <span style="color:#f92672">*</span>fds, nfds_t nfds, <span style="color:#66d9ef">int</span> timeout);
<span style="color:#66d9ef">struct</span> pollfd {
	<span style="color:#66d9ef">int</span>   fd;         <span style="color:#75715e">/* file descriptor */</span>
	<span style="color:#66d9ef">short</span> events;     <span style="color:#75715e">/* requested events */</span>
	<span style="color:#66d9ef">short</span> revents;    <span style="color:#75715e">/* returned events */</span>
};
</code></pre></div><h3 id="epoll-event-poll">Epoll (event poll)<a hidden class="anchor" aria-hidden="true" href="#epoll-event-poll">#</a></h3>
<p>Epoll instance is a kernel data structure. It allows for a process to monotor multiplex I/O on mltiple descriptors. You have 3 system call to control epoll instance :</p>
<h4 id="epoll_create">epoll_create()<a hidden class="anchor" aria-hidden="true" href="#epoll_create">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/epoll.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">epoll_create</span>(<span style="color:#66d9ef">int</span> size);
</code></pre></div><p>The size augrument, which is the number of descriptors, is ignored since Linux 2.6.8.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/epoll.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">epoll_create1</span>(<span style="color:#66d9ef">int</span> flags);
</code></pre></div><p>flags can only be either 0 or EPOLL_COLEXEC.</p>
<ol>
<li>flags is 0, it is the same as epoll_create().</li>
<li>flags is EPOLL_COLEXEC, it will set close-on-exec flag on the new file descriptor.</li>
</ol>
<h4 id="epoll_ctl">epoll_ctl()<a hidden class="anchor" aria-hidden="true" href="#epoll_ctl">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/epoll.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">epoll_ctl</span>(<span style="color:#66d9ef">int</span> epfd, <span style="color:#66d9ef">int</span> op, <span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">struct</span> epoll_event <span style="color:#f92672">*</span>event);
</code></pre></div><p>It preformed <strong>op</strong> on target <strong>fd</strong> in <strong>epfd</strong> with <strong>event</strong></p>
<h5 id="op">op<a hidden class="anchor" aria-hidden="true" href="#op">#</a></h5>
<ol>
<li>EPOLL_CTL_ADD</li>
<li>EPOLL_CTL_MOD</li>
<li>EPOLL_CTL_DEL</li>
</ol>
<h5 id="events">events<a hidden class="anchor" aria-hidden="true" href="#events">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">union</span> epoll_data {
	<span style="color:#66d9ef">void</span>        <span style="color:#f92672">*</span>ptr;
	<span style="color:#66d9ef">int</span>          fd;
	<span style="color:#66d9ef">uint32_t</span>     u32;
	<span style="color:#66d9ef">uint64_t</span>     u64;
} epoll_data_t;

<span style="color:#66d9ef">struct</span> epoll_event {
	<span style="color:#66d9ef">uint32_t</span>     events;      <span style="color:#75715e">/* Epoll events */</span>
	epoll_data_t data;        <span style="color:#75715e">/* User data variable */</span>
};
</code></pre></div><p>events is just a <strong>bitmask</strong> that indicates which events fd is being monitored for. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">EPOLLIN 	: The associated file is available for read operations.
EPOLLOUT 	: The associated file is available for write operations.
</code></pre></div><p>If you want to perform multiple events, just OR-ing them.</p>
<h4 id="epoll_wait">epoll_wait()<a hidden class="anchor" aria-hidden="true" href="#epoll_wait">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/epoll.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">epoll_wait</span>(<span style="color:#66d9ef">int</span> epfd, <span style="color:#66d9ef">struct</span> epoll_event <span style="color:#f92672">*</span>eventlist,
				<span style="color:#66d9ef">int</span> maxevents, <span style="color:#66d9ef">int</span> timeout);
</code></pre></div><p>blocks until any descriptor being monitored become ready for I/O</p>
<h2 id="the-bowels-of-epoll">The bowels of epoll<a hidden class="anchor" aria-hidden="true" href="#the-bowels-of-epoll">#</a></h2>
<h4 id="in-process">In process<a hidden class="anchor" aria-hidden="true" href="#in-process">#</a></h4>
<p>Let&rsquo;s first learn how the descriptor works. I create a file descriptor in process A, I will get a file descriptor. The system will store the descriptor and it&rsquo;s file pointer in a table in my process A. Every entry in this table has 2 fields :</p>
<ol>
<li>descriptor flags.</li>
<li>file pointer, point to an underlying kernel open file table.
indexed by descriptor.</li>
</ol>
<h4 id="in-kernel">In kernel<a hidden class="anchor" aria-hidden="true" href="#in-kernel">#</a></h4>
<p>Each file pointer point to an entry in kernel open file table. each entry in kernel open file table has 3 fields :</p>
<ol>
<li>file offset</li>
<li>status flags</li>
<li>inode pointer.</li>
</ol>
<h4 id="in-filesystem">In filesystem<a hidden class="anchor" aria-hidden="true" href="#in-filesystem">#</a></h4>
<p>Then each inode pointer point to an entry in filesystem  inode table. each entry in filesystem inode table has some fields :</p>
<ol>
<li>file type.</li>
<li>file locks.</li>
<li>etc.</li>
</ol>
<h3 id="how-epoll-works">How epoll works<a hidden class="anchor" aria-hidden="true" href="#how-epoll-works">#</a></h3>
<p>process A call <code>epoll_create()</code> to create an epoll instance. The system will create an entry in kernel open file table, and it point to an entry in inode table. secondly, process A call <code>epoll_ctl()</code> to add a file descriptor <code>fd0</code> to the epoll instance&rsquo;s interset list. The system will point the <code>fd0</code> in epoll instance to <code>fd0</code> in kernel open file table (NOTICE: the kernel open file table entry is shared by referenced descriptor !!)</p>
<h4 id="example">example<a hidden class="anchor" aria-hidden="true" href="#example">#</a></h4>
<p>Consider the situation above, process A fork process B without close-on-exec, process B will have table as same as process B. for example, process A have fd0 and fork process B, it have a descriptor fd1. But fd0 and fd1 point to the same underlying kernel open file table entry.</p>
<h4 id="fork-epoll">Fork epoll<a hidden class="anchor" aria-hidden="true" href="#fork-epoll">#</a></h4>
<p>So same case, but the fd0 and fd1 in the above case is epoll descriptor. process A call <code>epoll_wait()</code>, after a moment it got notifications. But at the same time, process B will also got the notifications !!!</p>
<p>So we can say once a file descriptor is registered by a process with the epoll instance, it will continue getting notifications about events on the descriptor even if it closes the descriptors as long as the underlying open file descriptor is still referenced by at least one descriptor.</p>
<h3 id="performance">Performance<a hidden class="anchor" aria-hidden="true" href="#performance">#</a></h3>
<p>Select and poll are O(N) (or O(number of descriptors being monitored)), but epoll is O(1) (or O(number of events that have occurred)). Because every time the descriptor become ready, kernel will add it into the ready list in epoll instance. Once process call <code>epoll_wait()</code>, just return the ready list.</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://BWbwchen.github.io/tags/epoll/">epoll</a></li>
      <li><a href="https://BWbwchen.github.io/tags/tcp/">tcp</a></li>
    </ul>






<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Epoll study on twitter"
        href="https://twitter.com/intent/tweet/?text=Epoll%20study&amp;url=https%3a%2f%2fBWbwchen.github.io%2fposts%2fhttp_server_in_go%2f&amp;hashtags=epoll%2ctcp">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Epoll study on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fBWbwchen.github.io%2fposts%2fhttp_server_in_go%2f&amp;title=Epoll%20study&amp;summary=Epoll%20study&amp;source=https%3a%2f%2fBWbwchen.github.io%2fposts%2fhttp_server_in_go%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Epoll study on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fBWbwchen.github.io%2fposts%2fhttp_server_in_go%2f&title=Epoll%20study">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Epoll study on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fBWbwchen.github.io%2fposts%2fhttp_server_in_go%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Epoll study on whatsapp"
        href="https://api.whatsapp.com/send?text=Epoll%20study%20-%20https%3a%2f%2fBWbwchen.github.io%2fposts%2fhttp_server_in_go%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Epoll study on telegram"
        href="https://telegram.me/share/url?text=Epoll%20study&amp;url=https%3a%2f%2fBWbwchen.github.io%2fposts%2fhttp_server_in_go%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2022 <a href="https://BWbwchen.github.io/">Bo-Wei Chen&#39;s Blog</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
