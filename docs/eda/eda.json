[
  {
    "path": "eda/bounded-radius-routing-algorithm/",
    "title": "Bounded Radius Routing Algorithm",
    "description": "Note for EDA routing algorithm - Bounded Radius Routing Algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-04-25",
    "categories": [
      "EDA",
      "routing",
      "CAD"
    ],
    "contents": "\n\nContents\nBPRIM(Bounded Prim)\nBRBC(Bounded Radius\nBounded Cost)\n\nHow to construct MST with bounded radius or bounded wire length for\nL-Shaped\nSteiner Routing Algorithm? We called it bounded radius MST.\nBPRIM(Bounded Prim)\nInitialize MST \\(T\\) with source\nnode \\(s\\) .\n\\(R\\) is the longest distance from\n\\(s\\) to the other node in \\(P\\) .\nfor each node \\(v\\) , which is the\nclosest neighbor to \\(T\\) and \\(v \\notin T\\)\nThe closest node with \\(v\\) is\n\\(y\\) , where \\(v \\notin T, y \\in T\\) .\ncheck \\(dist_T(s, v) + dist(v, y) \\leq (1\n+ \\epsilon)R\\) , where \\(\\epsilon\\) is user\nYes, add edge \\((v, y)\\) into \\(T\\) .\nNo, Find some node \\(v' \\in T\\)\nsuch that \\(dist_T(s, v') + dist(v' +\ny) \\leq R\\)\n\n\nBRBC(Bounded Radius Bounded\nCost)\nConstruct initial MST \\(Q\\)\nMake MST \\(Q\\) became a rooted tree\n\\(T_s\\)\nThe order of Depth-first search on \\(T_s\\) is \\(L\\)\nfor each \\(v \\in L\\) with ordered\niterating\ncheck \\(\\epsilon \\cdot dist(s, v) \\leq\nS\\) , where \\(S\\) is the\naccumulated cost of the path from the latest check point.\nYes!\nSet \\(S\\) became \\(0\\)\nthe start point of the calculation of \\(S\\) became \\(v\\) .\nAdd edge \\((s, v)\\) into \\(Q\\) .\n\nNo! do nothing.\n\nConstruct the shortest path tree on \\(Q\\) and it will become BR-MST.\nFind the shortest path from \\(s\\)\nto the other point and it is the shortest path tree.\n\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2020/09/06/08/00/red-thread-5548304_960_720.jpg",
    "last_modified": "2022-04-25T15:43:57+08:00",
    "input_file": {}
  },
  {
    "path": "eda/1-steiner-routing-algorithm/",
    "title": "1-Steiner Routing Algorithm",
    "description": "Note for EDA routing algorithm - 1-Steiner Routing Algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-04-21",
    "categories": [
      "EDA",
      "routing",
      "CAD"
    ],
    "contents": "\n\nContents\nNaive method\nHeuristic method\n\nGiven a MST with point set \\(P\\) ,\ndenoted \\(MST(P)\\) .\nFind one additional Steiner point \\(s\\) so that the wire length of \\(MST(P \\cup s)\\) is shorter than \\(MST(P)\\) .\nNaive method\nFind all possible 1-steiner points \\(P\\) by Hanan grid\nFor each 1-steiner points \\(s \\in\nP\\) , construct \\(MST(P \\cup\ns)\\) .\nFind the MST with shortest wirelength.\n\nrepeat above until no improvement.\nHeuristic method\nUse \\(\\textrm{gain}\\) to decide\nwhere to add steiner point.\npicture from book practical problems in\nVLSI physical design automation\n\\(\\textrm{gain}(p, e) =\n\\textrm{length}(e_2) - \\textrm{length}(p, p_1)\\)\n\\(p \\in P\\) , \\(e \\in MST(P)\\)\n\\(e_2\\) is the longest edge from\n\\(p\\) to edge \\(e\\) .\n\\(p_1\\) is the steiner point on\nhanan grid.\n\nfor each edge \\(e \\in\nMST(P)\\)\nFind the largest \\(\\textrm{gain}\\)\nvalue\nSort descending as \\(E\\) .\n\nfor each \\(g \\in E\\)\n\\(g = \\textrm{gain}(p, e)\\)\nremove corresponding \\(e_2\\) , and\nconnect \\(p\\) and \\(p_1\\) .\nIf edge \\(e\\) were removed by\nprevious operation, just skip it.\n\nrepeat above until no improvement.\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2020/09/06/08/00/red-thread-5548304_960_720.jpg",
    "last_modified": "2022-04-21T21:48:22+08:00",
    "input_file": {}
  },
  {
    "path": "eda/l-shaped-steiner-routing-algorithm/",
    "title": "L-shaped Steiner Routing Algorithm",
    "description": "Note for EDA routing algorithm - L-shaped Steiner Routing Algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-04-21",
    "categories": [
      "EDA",
      "routing",
      "CAD"
    ],
    "contents": "\n\nContents\nPrerequisite\nGoal\nAlgorithm\nConstruct minimum\nspanning tree\nDetermine\nthe shape of each edge(upper L or lower L) by DP in bottom-up\nfashion\nBrute force all possible\ncase\nVisit\nthe tree in top-down fashion to construct the steiner tree\n\n\nsolve the RST (Rectilinear Steiner Tree) problem by constructing a\nR-MST (Rectilinear Minimum Spanning Tree) and refine it.\nPrerequisite\n\\(cost(\\forall RMST) \\leq\n1.5cost(\\text{optimal } RST)\\)\nUse prim or kruskal algorithm to construct the minimum spanning\ntree.\nGoal\nMaximize the number of overlapping edges.\nAlgorithm\nhttps://i.imgur.com/f1FDkYj.pngConstruct minimum spanning\ntree\n\\(\\textrm{weight}(i, j) = (D(i, j), -|y(i)\n- y(j)|, -\\max\\{x(i), x(j)\\})\\)\nWe want to find the shortest edges, larger vertical distance and\nrightmost vertices.\nDetermine\nthe shape of each edge(upper L or lower L) by DP in bottom-up\nfashion\nCalculate \\(\\Phi_\\ell(v)\\) and\n\\(\\Phi_u(v)\\)\n\\(\\Phi_\\ell(v)\\) means the number\nof overlapping edge when \\(e_v\\) is\nlower L.\n\\(\\Phi_u(v)\\) means the number of\noverlapping edge when \\(e_v\\) is upper\nL.\nBrute force all possible\ncase\n\\(\\Phi_{\\ell \\text{ or } u}(v) = \\max(Z_1\n+ Z_2)\\)\n\\(Z_1 =\\) overlap in all of edges\nincident to \\(v\\)\nCalculate the overlapping of \\(e_v\\) with all the combinations of the\nchildren of \\(v\\) (lower or upper\nL)\n\n\\(Z_2 =\\) overlap in the children\nof \\(v\\)\nSum up the corresponding combination’s \\(\\Phi_\\ell(k)\\) or \\(\\Phi_u(k)\\) , \\(k\\) is the children of \\(v\\)\n\n\nVisit\nthe tree in top-down fashion to construct the steiner tree\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2020/09/06/08/00/red-thread-5548304_960_720.jpg",
    "last_modified": "2022-04-21T21:48:48+08:00",
    "input_file": {}
  },
  {
    "path": "eda/timberwolf-algorithm/",
    "title": "TimberWolf algorithm",
    "description": "Note for EDA placement algorithm - TimberWolf algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-31",
    "categories": [
      "EDA",
      "placement",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nAlgorithm\nState\nCost function\nDelta of cost function\n\nOverlapping causing by\nexchanging\n\n\noriginal\npaper\nGoal\nGlobal and detail standard cell placement.\nAlgorithm\nUsing Simulate\nAnnealing algorithm\nState\nrandom initial placement or wiring configuration\nnew state is generated by\nSwap: exchanging 2 fundamental units\n(big, small) -> (small, big)\nbig -> small will cause overlap. shift it!(to the less shift\namount side)\nsmall -> big will make some small gap. do nothing. (It will be\nused for the later shift for the big block)\n\nMove: moving a unit to another row\nMirror: Reflect the cell orientation around the y-axis\n#EDAproblem\n\nCost function\ntotal estimated wire length\nhalf-perimeter of the bounding box of the net.\nDelta of cost function\n\\(\\Delta C = \\Delta W + \\Delta\nW_s\\)\n\\(\\Delta W\\) is the wire length\nchange due to new state. (real result)\nCalculate the effected nets’ change.\n\n\\(\\Delta W_s\\) is the wire length\nchange due to shifting the cells to remove the overlap. (estimated\nresult)\nestimated the \\(\\Delta W_s\\) by gradient\nFind the nets, which contain the shifted block, and find the left\nand right boundary.\nIf the shifted block is on the right boundary, the gradient\nshould increase.\nIf the shifted block is on the left boundary, the gradient should\ndecrease.\nelse, gradient remain unchange.\n\\(\\Delta W_s = \\sum_{j \\in\nshifted\\_cell} gradient(j) \\cdot shift\\_amount(j)\\)\nOverlapping causing by\nexchanging\nUse penalty function #EDAproblem\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2018/03/13/22/53/puzzle-3223941_960_720.jpg",
    "last_modified": "2022-04-21T22:00:13+08:00",
    "input_file": {}
  },
  {
    "path": "eda/gordian-algorithm/",
    "title": "GORDIAN algorithm",
    "description": "Note for EDA placement algorithm - GORDIAN algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-23",
    "categories": [
      "EDA",
      "placement",
      "CAD"
    ],
    "contents": "\n\nContents\nMath\nAlgorithm\n\nUse analytical method and linear programming video\nMath\nGoal is to minimize the total square of wire length\nthe sum of square wire length between each moveable\nnodes(gates).\nthe sum of square wire length between moveable nodes(gates) and\nfixed nodes(pin).\n\nObjective function(minimize it)\nx axis : \\(\\frac{1}{2}x^TLx +\nd_x^Tx\\)\ny axis : \\(\\frac{1}{2}y^TLy +\nd_y^Ty\\)\n\nAlgorithm\nConstruct the k-clique graph for each net\nthe weight will be \\(\\frac{2}{k}\\)\n\nBuild the laplacian matrix and write down the objective\nfunction\niterative optimize it\nfor the first time\nminimize without any constraint\n\nfor the other time\nminimize with balance factor \\(\\alpha\\)\nminimize objective function above and constraint\ncenter of gravity constraint\nthe center of gravity of nodes in separated part should match the\ncenter of gravity constraint\n\n\n\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2018/03/13/22/53/puzzle-3223941_960_720.jpg",
    "last_modified": "2022-03-27T23:05:16+08:00",
    "input_file": {}
  },
  {
    "path": "eda/mincut-placement/",
    "title": "Mincut placement with propagation ",
    "description": "Note for EDA placement algorithm - Mincut placement with propagation",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-20",
    "categories": [
      "EDA",
      "placement",
      "CAD"
    ],
    "contents": "\n\nContents\nMincut placement\nTerminal propagation\n\nMincut placement\nRepeatedly split the circuit into sub-circuits by [[Partitioning]]\nalgorithm.\nUntil each partition only occupied by a single gates (or sometimes\nspecial sub-circuits).\nTerminal propagation\nDuring the first partition, there are some cases that two gate\n\\(x\\) and \\(y\\) is in the adjacent block.(wire length =\n1)\nBut at the second partition, we tried to partition the block of\n\\(x\\) and make \\(x\\) away from \\(y\\) (wire length = 2)\nWe need to connect the \\(x\\) and\n\\(y\\) to prevent the additional wire\nlength.\nhttps://i.imgur.com/1oIpQof.png\\(m\\) and \\(i\\) should be in the same partition and at\nthe left most side, otherwise we need more wire length.\n\n",
    "preview": "https://cdn.pixabay.com/photo/2018/03/13/22/53/puzzle-3223941_960_720.jpg",
    "last_modified": "2022-03-27T23:05:20+08:00",
    "input_file": {}
  },
  {
    "path": "eda/ilp-floorplanning-algorithm/",
    "title": "ILP floorplanning algorithm ",
    "description": "Note for EDA floorplanning algorithm - ILP floorplanning algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-17",
    "categories": [
      "EDA",
      "floorplanning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nIdea\nAlgorithm\nFor flexible module\nProblem\n\nGoal\nGiven some module with width and height, and some constraint(eg.\nrotation or not .etc), output the minimize(eg. area .etc)\nfloorplanning.\nSuitable for fixed and flexible module.\nIdea\nThere are so many constraint(eg. module size, rotation or not .etc)\nand one objective function(minimize floorplanning) to optimize.\nUse Integer Linear programming to solve it!!\nOnly consider the integer solution by branch and bound. video\n\nAlgorithm\nObjective function: minimize \\(y^*\\) , it is the width of total chip\nsize(square chip here).\nUse \\((x_{ij}, y_{ij})\\) pair to\ndefine the location relationship of module \\(i\\) and \\(j\\) .\nUse \\(z_i\\) to mark rotation or\nnot. \\(z_i = 0\\) mean we will NOT\nrotation the module \\(i\\) .\nNon-overlapping constraint\nWrite down each pair of module and avoid the overlapping. Below is\none of the example.\n\n\nVariable constraint\nSize of module should positive.\nrelationship variable should be binary.\n\n\nChip width constraint\n\n\nChip height constraint\n\n\nFor flexible module\nConstraint style is same as above.\nSince the width and height of flexible module can be changed, only\narea and aspect ratio is given, We want to obtain the\nLinear relationship between height and width.\nUse Taylor\nexpansion!\n\\(hw = S\\) , \\(S\\) is the area.\n\\(h = \\frac{S}{w} = \\frac{S}{w_{max}} +\n(w_{max} - w)\\frac{S}{w_{max}^2} + \\dots\\)\nUse more term can obtain more accuracy.\n\n\nProblem\nFor flexible module, we use taylor expansion to approximate the\nrelationship between width and height.\nSince it is approximate value, we will have some error value\nthere.\nSolution: Use more term to get high quality answer.\n\n",
    "preview": "https://cdn.pixabay.com/photo/2016/11/24/20/30/architecture-1857175_960_720.jpg",
    "last_modified": "2022-03-27T23:03:14+08:00",
    "input_file": {}
  },
  {
    "path": "eda/normalized-polish-expression/",
    "title": "Normalized Polish Expression ",
    "description": "Note for EDA floorplanning algorithm - Normalized Polish Expression",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-16",
    "categories": [
      "EDA",
      "floorplanning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nProperty of\nnormalized polish expression\nIdea\nAlgorithm\nProblem\n\nGoal\nGiven the polish expression of a slicing tree, output the minimum\nsize of floor planning.\n\\(PE = 25V 1H374V H6V 8V H\\)\n\nProperty of normalized\npolish expression\nEach block(operand) appears exactly once in the string. (eg. only\none 2 or 5 in the string)\nBalloting property\nThe number of operands is larger than the number of operators\n\nNormality property\nNo consecutive operators of the same type in the string\n1-1 correspondence to a slicing tree. (NPE can obtain an unique\nslicing tree)\n\nIdea\nUse Simulate Annealing algorithm\nWhat is the neighbor of the current polish expression?\n\\(Move_1\\) : Swap adjacent\noperands.\neg. 25V -> 52V or 374V -> 734V\n\n\\(Move_2\\) : Swap two operators.\neg. 25V1H -> 25H1V\n\n\\(Move_3\\) : Swap adjacent operand\nand operator.\neg. 6V8V -> V68V\nNOTICE!! need to keep the Balloting property and Normality property\n.\n\n\nAlgorithm\nRandom polish expression \\(PE_0\\)\nParameters for Simulate Annealing algorithm\n\\(T_0\\) and \\(T_{end}\\)\nCooling rate \\(\\alpha\\)\nNumber of move at each temperature \\(M_t\\)\n\n\\(Z\\) is the optimal answer that we\ncurrently have\nFor \\(i\\) in each temperature\nPerform one of the three type of move above \\(PE_i'\\)\n\\(C_i = A_i + \\lambda \\cdot W_i\\)\n\\(C_i\\) is the cost of \\(PE_i'\\)\n\\(A_i\\) is the area of \\(PE_i'\\)\n\\(\\lambda\\) is a\nhyperparameter\n\\(W_i\\) is the wirelength of \\(PE_i'\\)\n\n\\(\\Delta C = C_i - C_{i-1}\\)\nDecide whether to accept this proposal\nIf \\(\\Delta C > 0\\)\nAccept this change\n\nelse\nCalculate the probability \\(p = exp(\\Delta\nC / T_i)\\)\nIf \\(p > rand(0, 1)\\)\nAccept this change\n\nelse\nReject this change\n\n\n\nUpdate the temperature\n\\(T = \\alpha T\\)\n\n\nProblem\nHow to generate the initial slicing tree input?\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2016/11/24/20/30/architecture-1857175_960_720.jpg",
    "last_modified": "2022-03-27T23:02:34+08:00",
    "input_file": {}
  },
  {
    "path": "eda/stockmeyer-algorithm/",
    "title": "Stockmeyer algorithm ",
    "description": "Note for EDA floorplanning algorithm - Stockmeyer algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-15",
    "categories": [
      "EDA",
      "floorplanning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nIdea\nAlgorithm\nProblem\n\nGoal\nGiven a slicing tree, output the minimum size of floor\nplanning.\n\nIdea\nFor 2 child with dimension \\((h_l,\nw_l)\\) and \\((h_r, w_r)\\)\nFor vertical node(eg. 1, 5 in the figure above)\n\\(D = (width_1 + width_2, max(height_1,\nheight_2))\\)\n\nFor horizontal node(eg. 2, 8 in the figure above)\n\\(D = (max(width_1, width_2), height_1 +\nheight_2)\\)\n\nAlgorithm\nObjective\nLeft child with dimension \\((h_l,\nw_l)\\)\nRight child with dimension \\((h_r,\nw_r)\\)\nList \\(L = \\{(h_l, w_l), (w_l,\nh_l)\\}\\) sort by the first or second element.\nList \\(R = \\{(h_l, w_l), (w_l,\nh_l)\\}\\) sort by the first or second element.\n\nFor vertical node\n\\(L, R\\) sort by the first\nelement\nLike merge two sorted list\n\\(l = l_1, r = r_1\\)\nif \\(l.second > r.second\\) ,\nthen \\(l = l_{next}\\)\nif \\(l.second < r.second\\) ,\nthen \\(r = r_{next}\\)\nif \\(l.second = r.second\\) , then\n\\(l = l_{next}, r = r_{next}\\)\n\nIt will generate a dimension list \\(D\\) contain multiple dimension\ncombination.\nWith \\(D = (width_1 + width_2,\nmax(height_1, height_2))\\)\n\nFor horizontal node\nLike above, but with \\(D = (max(width_1,\nwidth_2), height_1 + height_2)\\)\nLike merge two sorted list\n\\(l = l_1, r = r_1\\)\nif \\(l.first > r.first\\) , then\n\\(l = l_{next}\\)\nif \\(l.first < r.first\\) , then\n\\(r = r_{next}\\)\nif \\(l.first = r.first\\) , then\n\\(l = l_{next}, r = r_{next}\\)\n\n\nNow we know the total floor planning area by bottom-up the slicing\ntree.\nTo get the location of each node in the slicing tree, traverse the\nslicing tree top-down.\nProblem\nHow to generate the initial slicing tree input?\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2016/11/24/20/30/architecture-1857175_960_720.jpg",
    "last_modified": "2022-03-27T23:02:58+08:00",
    "input_file": {}
  },
  {
    "path": "eda/fbb-algorithm/",
    "title": "FBB algorithm ",
    "description": "Note for EDA partitioning algorithm - FBB algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-14",
    "categories": [
      "EDA",
      "partitioning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nRe-construct the flow\nnetwork\nIteratively\ncall the maximum-flow algorithm\n\nGoal\nBalanced bipartition.\ndivided the circuit into 2 equal-sized partitions.\nRe-construct the flow\nnetwork\nTurn the original circuit into bi-directed graph\nhttps://i.imgur.com/xbvXKhs.pngfor each net \\(n\\) (hyperedge)\nadd vertices into graph \\(G\\)\nadd two auxiliary nodes \\(n_1\\) and\n\\(n_2\\) into the graph \\(G\\) with edge of capacity \\(0\\)\nconnect the vertices into \\(n_1\\)\nand \\(n_2\\) into all the vertices with\nedge of capacity \\(\\infty\\)\n\n\nIteratively call\nthe maximum-flow algorithm\nRandomly select 2 vertices as \\(s\\)\nand \\(t\\) for maximum-flow\nalgorithm.\nFound the augmenting path \\(AG\\)\n(maybe multiple paths)\nThere are some net \\(n\\) in the\n\\(AG\\) , check whether it will\nconstruct the balanced partition.\nYes\nWe found the partition with cut size equals to the maximum flow\nvalue.\n\nNo, We got a cut \\(C(X, X')\\)\nif \\(|X|\\) has less vertices, merge\nthe random vertices in \\(X'\\) into\nvertex \\(s\\) , vice versa.\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2017/07/13/19/30/texture-2501600_960_720.jpg",
    "last_modified": "2022-04-25T15:49:39+08:00",
    "input_file": {}
  },
  {
    "path": "eda/eig-algorithm/",
    "title": "EIG algorithm",
    "description": "Note for EDA partitioning algorithm - EIG algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-13",
    "categories": [
      "EDA",
      "partitioning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nLaplacian matrix \\(L\\) of graph \\(G\\)\n\\(\\lambda_2\\) optimization for symmetric\nmatrix\nAlgorithm\n\nGoal\nBalanced bipartition.\ndivided the circuit into 2 equal-sized partitions. # Graph in Linear\nalgebra\ngood\nexplanation\n\\(A\\) is adjacency matrix of\nundirected graph \\(G\\) .\n\\(x\\) is a vector and is a value of\neach node in \\(G\\) .\n\\(Ax = y\\) and what is the meaning\nof \\(y\\) ?\n\\(y_i = \\sum_{(i, j) \\in E(G)}\nx_j\\)\n\\(y_i\\) is the sum of the neighbor\nvalue of \\(x_i\\)\n\n\\(Ax = \\lambda x\\)\nSince \\(A\\) is symmetric matrix\n\\(\\rightarrow\\) eigenvector are real\nand orthogonal!\n\nLaplacian matrix \\(L\\) of graph \\(G\\)\n\\(D\\) is degree matrix.\n\\(D_{ii} =\\) degree of vertex \\(v_i\\) .\n\\(D_{ij} = 0, i \\neq j\\)\n\n\\(L = D-A\\)\n\\(L's\\) trivial eigenpair\n$ [1, , 1] ^T $\nwith \\(\\lambda = 0\\)\n\n\n\\(\\lambda_2\\) optimization for symmetric\nmatrix\n\\(\\lambda_2 = min_x\n\\frac{x^TLx}{x^Tx}\\)\nThe meaning of \\(x^TLx\\)\n\\(x^TLx = \\sum_{i, j = 1}^{n} L_{ij}x_jx_i\n= \\sum_{i, j = 1}^{n} (D_{ij} - A_{ij})x_jx_i =\\\\ \\sum_{i, j = 1}^{n}\nD_{ij}x_jx_i - \\sum_{i, j = 1}^{n} A_{ij}x_jx_i = \\\\ \\sum_{i= 1}^{n}\nD_{ii}x_i^2 - \\sum_{(i, j) \\in E(G)} 2x_jx_i = \\\\ \\sum_{(i, j) \\in E(G)}\nx_i^2 - 2x_jx_i + x_j^2 =\\\\ \\sum_{(i, j) \\in E(G)} (x_i -\nx_j)^2\\)\n\nProperty of \\(x\\)\n\\(x\\) is an unit vector \\(\\rightarrow \\sum_{i} x_i^2 = 1\\)\n\\(x\\) is orthogonal with 1st\neigenvector \\(\\rightarrow \\sum_i x_i =\n0\\)\n\nBack to \\(\\lambda_2 = min_x\n\\frac{x^TLx}{x^Tx} = min_x \\frac{\\sum_{(i, j) \\in E(G)} (x_i -\nx_j)^2}{\\sum_i x_i^2} =\\)\n\\(\\lambda_2 = min_x \\sum_{(i, j) \\in E(G)}\n(x_i - x_j)^2\\)\n\\(\\sum_{(i, j) \\in E(G)} (x_i -\nx_j)^2\\) means we don’t want to cross the group.\n\\(\\sum_i x_i = 0\\) means we need to\nbalance this two group.\n\n\nWe can use \\(0\\) or the median\nvalue of \\(x_i\\) to split the\ngroup.\nAlgorithm\nRe-calculate the graph\nfor each net \\(n\\) with size \\(k\\)\nconstruct the \\(k\\) -clique models\nwith weight of \\(\\frac{1}{k-1}\\)\nor we can use intersection graph.\n\n\nBuild the Laplacian matrix \\(L\\)\n\nCompute the second smallest eigenvalue and eigenvector \\(x\\) using [[Lanczos algorithm]].\n\nSort \\(x\\)\n\nUse sorted \\(x\\) to evaluate \\(n-1\\) partitioning solutions\n\\(((v_1), (v_2, \\dots, v_n))\\)\n\\(((v_1, v_2), (v_3, \\dots,\nv_n))\\)\nand so on\n\nCalculate each partition’s ratio cuts\nratio cut \\(= \\frac{c(X, Y)}{|X||Y|} =\n\\frac{\\text{cut size}}{\\text{size of X} \\times \\text{size of\nY}}\\)\n\nChoose partitioning with smallest ratio cut and balanced\npartition.\n\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2017/07/13/19/30/texture-2501600_960_720.jpg",
    "last_modified": "2022-03-27T23:00:36+08:00",
    "input_file": {}
  },
  {
    "path": "eda/fm-algorithm/",
    "title": "Fiduccia and Mattheyses algorithm (FM algorithm) ",
    "description": "Note for EDA partitioning algorithm -  Fiduccia and Mattheyses algorithm (FM algorithm)",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-10",
    "categories": [
      "EDA",
      "partitioning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nApplied directly on\nhypergraph\nBucket data structure\nIteratively\nmove(each iteration is called “pass”)\n\nGoal\nBalanced bipartition.\ndivided the circuit into 2 equal-sized partitions.\nApplied directly on\nhypergraph\nBucket data structure\nLike bucket sort, we first prepare some bucket to boost the sorting\nprocess.\nBucket size\nfrom \\(max(\\forall size(edge))\\) to\n\\(-max(\\forall size(edge))\\)\n\nIteratively\nmove(each iteration is called “pass”)\nRandomly bipartitioning the graph \\(G\\) with hyperedge\nDo procedure on the unmarked vertex until no\nunmarked exist\nFirst compute the gain value for all node.\n\\(x \\in P_1\\)\n\\(FS(x)\\) is the number of nets\nthat have \\(x\\) as the only cell in\n\\(P_1\\)\n\\(TE(x)\\) is the number of nets\nthat contain \\(x\\) and are entirely in\n\\(P_1\\)\n\\(gain(x) = FS(x) - TE(x)\\)\n\nmove the vertex \\(x\\) with maximum\nvalue of gain to the opposite under the area constraint, and then\nmark vertex \\(x\\)\nUse bucket to sort the maximum value.\narea constraint(after moving) : \\(|size(P_1) - size(P_2)| \\leq 1\\)\n\nre-compute the gain value of the unmarked neighbor\nvertex of \\(x\\) .\nRecord the \\(gain(x, y)\\) and the\ncurrent cut size\n\nIf the initial cut size has reduced during the current “pass”\nDo the other “pass” on the best solution\nOtherwise, terminate.\n\n",
    "preview": "https://cdn.pixabay.com/photo/2017/07/13/19/30/texture-2501600_960_720.jpg",
    "last_modified": "2022-03-27T23:00:25+08:00",
    "input_file": {}
  },
  {
    "path": "eda/kl-algorithm/",
    "title": "Kernighan and Lin algorithm (KL algorithm)",
    "description": "Note for EDA partitioning algorithm - Kernighan and Lin algorithm (KL algorithm)",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-03",
    "categories": [
      "EDA",
      "partitioning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nRewrite\nthe original circuit graph into edge-weighted undirected graph \\(G\\)\nIteratively\nswap(each iteration is called “pass”)\n\nGoal\nBalanced bipartition.\ndivided the circuit into 2 equal-sized partitions.\nRewrite\nthe original circuit graph into edge-weighted undirected graph \\(G\\)\nRewrite the original circuit graph with hyper-edge, and it can share\nthe same node.\nEdge weight \\(c(x, y)\\) = \\(\\frac{1}{|e| - 1}\\) , where \\(e\\) is a hyper-edge and \\(|e|\\) is the size of that hyper-edge.\n\nIteratively\nswap(each iteration is called “pass”)\nRandomly bipartitioning the graph \\(G\\) (above rewritten graph)\nDo procedure on the unmarked vertex until no\nunmarked exist\nCompute all the possible swap pairs on the unmarked\nvertex.\nfor vertex \\(x \\in P_1\\) , we\ndefine:\n\\(E_x = \\sum_{i \\in P_2} c(x, i)\\)\nThis is the cut size of outward edge.\n\\(I_x = \\sum_{i \\in P_1} c(x, i)\\)\nThis is the cut size of inward edge.\n\nfor vertex \\(x \\in P_1, y \\in P_2\\)\n, if we swap them, the decrease of the cut size between \\(P_1\\) and \\(P_2\\) is :\n\\(gain(x, y) = (E_x - I_x - c(x, y)) +\n(E_y - I_y - c(x, y))\\)\n\n\nFind the pair with maximum \\(gain(x,\ny)\\) , swap \\((x, y)\\) , and\nthen mark vertex \\(x\\)\nand \\(y\\) .\nRecord the \\(gain(x, y)\\) and the\ncurrent cut size\n\nIf the initial cut size has reduced during the current “pass”\nDo the other “pass” on the best solution\nOtherwise, terminate.\n\n",
    "preview": "https://cdn.pixabay.com/photo/2017/07/13/19/30/texture-2501600_960_720.jpg",
    "last_modified": "2022-03-27T22:59:47+08:00",
    "input_file": {}
  },
  {
    "path": "eda/flowmap-algorithm/",
    "title": "FlowMap algorithm ",
    "description": "Note for EDA cluster algorithm - FlowMap algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-01",
    "categories": [
      "EDA",
      "clustering",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nAssumption\nUser constraint\nLabeling phase\nMapping phase\n\nFor the talk slide: link\nGoal\nTranslate the boolean network to K-input lookup table. (with input\npin constraint)\nFor FPGA K-input lookup table.\nThe maximum delay from PI to PO is minimized.\nAssumption\nDAG\neach node has a 0 delay\ninter-cluster has unit delay\nintra-cluster has 0 delay\nUser constraint\npin limit\nLabeling phase\nGet a topological sort : \\(T\\)\n(without PI)\n\\(l\\) is the delay.\neach node has a 0 delay\n\nFor each ordered node \\(t\\) ,\nconstruct graph \\(N_t\\) , which\ncontains all of the parent of \\(t\\) .\nthen add a source node \\(S\\) to \\(N_t\\) and connect it to all PIs node.\nCompute \\(p = max(l(\\forall \\text{fan-in\nnode of }t))\\)\nConstruct \\(N_t '\\) , where\n\\(l(v) = p, v \\in N_t\\) , \\(v\\) will be collapsed into \\(t\\) (同樣的 p值則縮點)\nConstruct a flow-network \\(N_t''\\) and duplicate the none-\n\\(s\\) and none- \\(t\\) node -> \\((x, x'), e(x, x') = 1\\) , the other\nedge are \\(\\infty\\)\nFind the cut \\(C(X'',\n\\bar{X''})\\) with cut size(number of edge in this cut)\n\\(\\leq\\) pin constraint\nIf found\n\\(cluster(t)\\) or in the paper\n\\(\\overline{X_t} = \\text{collapsed node and t}\n\\in N_t'\\)\n\\(l(t) = p\\)\n\nIf not found\n\\(cluster(t)\\) or in the paper\n\\(\\overline{X_t} = t\\)\n\\(l(t) = p + 1\\)\n\n\n\\(l_v = max(l_1, l_2)\\) (maximum\ndelay of node \\(v\\) with\ncluster size limit)\n\nMapping phase\nTry to combine some cluster.\nPut all PO nodes in a set \\(L\\)\nAnswer clusters will be in \\(S\\)\nFor each remove node \\(v\\) from\n\\(L\\)\nPush \\(cluster(v)\\) in to \\(S\\)\n\\(L = L \\cup input \\text{-}\nnode(cluster(v))\\) , where the node in \\(input \\text{-} node(cluster(v))\\) have not\nformed the cluster yet also not PI nodes(not in the answer set \\(S\\) yet).\n\nUntil \\(L\\) empty.\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2014/07/08/10/47/team-386673_960_720.jpg",
    "last_modified": "2022-04-24T11:31:14+08:00",
    "input_file": {}
  },
  {
    "path": "eda/rajaraman-and-wong-algorithm/",
    "title": "Rajaraman and Wong algorithm",
    "description": "Note for EDA cluster algorithm - Rajaraman and Wong algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-02-28",
    "categories": [
      "EDA",
      "clustering",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nAssumption\nUser constraint\nLabeling phase\nClustering phase\n\nFor the talk slide: link\nGoal\nMaximum delay from PI(primary input) to PO(primary output) is\nminimized\nAssumption\nDAG\neach node has a unique delay\ninter-cluster has constant delay\nintra-cluster does not incur any delay\nUser constraint\nNode delay\nEdge delay\nCluster size limit\nLabeling phase\nCompute \\(\\Delta(x, v)\\) , which\nmeans the maximum delay from \\(x\\) to\n\\(v\\)\nGet a topological sort : \\(T\\)\n(without PI)\n\\(l\\) is the delay.\nPI node : 1\nnon-PI node initialize with 0\n\nFor each ordered node \\(v\\) ,\nconstruct graph \\(G_v\\) , which\ncontains all of the parent of \\(v\\)\nCompute \\(l_v(x)\\) , \\(x \\in G_v / {v}\\)\n\\(l_v(x) = l(x) + \\Delta(x, v)\\) (\nthe delay of path from PI to \\(x\\) then\nto \\(v\\) )\n\nSort \\(l_v(x)\\) in decreasing\norder: \\(S\\)\nPush the element one-by-one from \\(S\\) to \\(cluster(v)\\) with cluster size\nlimit\nComputer \\(l_1\\) (intra-cluster\ndelay) and \\(l_2\\) (inter-cluster\ndelay).\nIf \\(cluster(v)\\) contains any PI\nnodes\n\\(l_1 = max(l_v(\\forall PI \\text{ }\nnode))\\)\n\nIf size of \\(S\\) is bigger than\ncluster size limit\n\\(l_2 = max(l_v(\\forall x) + D), x \\in G_v\n/ v\\) , \\(D\\) is inter-cluster\ndelay.\n\n\n\\(l_v = max(l_1, l_2)\\) (maximum\ndelay of node \\(v\\) with\ncluster size limit)\n\nClustering phase\nTry to combine some cluster.\nPut all PO nodes in a set \\(L\\)\nAnswer clusters will be in \\(S\\)\nFor each remove node \\(v\\) from\n\\(L\\)\nPush \\(cluster(v)\\) in to \\(S\\)\n\\(L = L \\cup input \\text{-}\nnode(cluster(v))\\) , where the node in \\(input \\text{-} node(cluster(v))\\) have not\nformed the cluster yet(not in the answer set \\(S\\) yet).\n\nUntil \\(L\\) empty.\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2014/07/08/10/47/team-386673_960_720.jpg",
    "last_modified": "2022-04-18T23:53:55+08:00",
    "input_file": {}
  }
]
