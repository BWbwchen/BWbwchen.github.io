[
  {
    "path": "eda/hmetis/",
    "title": "hMetis",
    "description": "Note for EDA cluster algorithm - hMetis algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-05-22",
    "categories": [
      "EDA",
      "clustering",
      "CAD"
    ],
    "contents": "\n\nContents\nWhat properties?\n\nFor the talk slide: link\n用於降低計算複雜度，因此將相同性質的 vertex group\n在一起，做完演算法之後再將 group 打開\nWhat properties?\nEdge coarsening (EC)\nGoal is to minimize the edge weight in the clustering graph.\nunmarked all node in the graph.\nfor each node \\(v\\) in random\norder:\ncalculate the edge weight of \\(e(v,\nu)\\) , \\(u\\) is the neighbor of\n\\(v\\)\nfind the edge \\(e(v, u)\\) with\nmaximum edge weight\nedge weight \\(= \\frac{1}{|h|-1}\\) ,\nwhere \\(h\\) is the edge contain \\(v\\) and \\(u\\) .\n\nMerge \\(v\\) and \\(u\\) .\nMarked \\(v\\) and \\(u\\) .\nuntil no unmarked node.\n\nHyperedge coarsening (HEC)\nSort the hyperedge.\nunweighted edge should be in increasing edge size order.\nweighted edge should be in decreasing edge weight order.\n\nFor each sorted edge \\(e\\)\nif all node in \\(e\\) are unmarked,\nthey became a cluster and marked them.\nelse, skip it.\n\nUnmarked remain node became a cluster of its own.\nModified hyperedge\ncoarsening (MHEC)\nSame as above, but different at the process for the remain\nnode.\nSort the hyperedge.\nunweighted edge should be in increasing edge size order.\nweighted edge should be in decreasing edge weight order.\n\nFor each sorted edge \\(e\\)\nif all node in \\(e\\) are unmarked,\nthey became a cluster and marked them.\nelse, skip it.\n\nUnmarked remain node became a big cluster.\nThis method tends to further reduce the hyperedge counts after\nclustering and balance the size among the clusters.\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2014/07/08/10/47/team-386673_960_720.jpg",
    "last_modified": "2022-05-22T22:22:01+08:00",
    "input_file": {}
  },
  {
    "path": "eda/multi-commodity-flow-routing-algorithm/",
    "title": "Multi-Commodity Flow Routing Algorithm",
    "description": "Note for EDA routing algorithm - Multi-Commodity Flow Routing Algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-05-19",
    "categories": [
      "EDA",
      "routing",
      "CAD"
    ],
    "contents": "\n\nContents\nMulti-Commodity Flow\nProblem\nMulti-net routing\nproblem\nNotation\nMethod 1:\nILP(integer linear programming)\nInteger constraint\nObjective function\nDemand constraint\nCapacity constraint \\(c\\)\n\nMethod 2:\nheuristic algorithm, MM(minimax)\nStep\n1: Compute the shortest path for all nets while ignoring capacity\nconstraints.\nStep\n2: Compute \\(M_r\\) , the maximum\noverflow value among all arcs.\nStep 3: Obtain \\(J_r\\) and \\(J_r^0\\)\nStep\n4: Assign \\(\\infty\\) as the cost of all\narcs in \\(J_r^0\\)\nStep 5: Obtain \\(K_r\\) and \\(K_r^0\\)\nStep\n6: Re-compute the shortest path for all nets in \\(K_r\\) with new cost(Some arcs are \\(\\infty\\) )\nStep\n7-1: We find some nets with non- \\(\\infty\\) cost.\nStep\n7-2: All nets are \\(\\infty\\) cost.\n(Maybe unsolvable or need to rip up the nets)\nStep\n8: Construct the new routing solution by change the net \\(k_0\\) with new routing path only.\nStep 9:\nBack to Step 1, until the maximum overflow \\(\\leq 0\\) .\n\n\nMulti-Commodity Flow Problem\nA generalization of the network flow problem, where multiple\ncommodities must be shipped from their own source to the sinks on a\ncommon network.\nThe goal is to minimized the total shipping cost.\nNP-Complete. Usually solved by LP solver.\nMulti-net routing problem\nWe can formulate the multi-net routing problem as a multi-commodity\nflow problem.\nWe can route all nets simultaneously!\nNotation\nFor edge \\(e(x, y)\\) in the network\ngraph\nThere are 2 directed arcs:\n\\(\\text{arc}(x, y)\\) and \\(\\text{arc}(y, x)\\)\n\n\nMethod 1: ILP(integer\nlinear programming)\n\\(x_a^k\\) means that the arc a in\nnet k is being used(1) or not(0).\nInteger constraint\n\\(x_a^k \\in \\{0, 1\\}\\)\nObjective function\n\\(\\min \\sum_{a \\in \\text{arc, } k \\in\n\\text{nets}} x_a^k \\times w(a)\\)\nDemand constraint\nGiven a node \\(v \\in V\\) and a net\n\\(k \\in \\text{nets}\\) , we define a\nvariable \\(z_a^k\\) .\n\\(z_a^k \\in \\{-1, 0, 1\\}\\) .\n-1 means node \\(v\\) is a sink node\nin net \\(k\\) .\n\\(x_a^k + x_{a'}^k = -1,\na'\\) is the inverse direction of \\(a\\)\n\n1 means node \\(v\\) is a source node\nin net \\(k\\) .\n\\(x_a^k + x_{a'}^k = 1,\na'\\) is the inverse direction of \\(a\\)\n\n0 means node \\(v\\) is NEITHER a\nsource node NOR a sink node in net \\(k\\) .\n\\(x_a^k + x_{a'}^k = 0,\na'\\) is the inverse direction of \\(a\\)\n\nCapacity constraint \\(c\\)\n\\(\\sum_{k \\in \\text{nets}} x_a^k +\nx_{a'}^k \\leq c, a'\\) is the inverse direction of \\(a\\)\nAnd use LP solver to solve the answer.\nMethod 2: heuristic\nalgorithm, MM(minimax)\nStep\n1: Compute the shortest path for all nets while ignoring capacity\nconstraints.\nStep\n2: Compute \\(M_r\\) , the maximum\noverflow value among all arcs.\nStep 3: Obtain \\(J_r\\) and \\(J_r^0\\)\n\\(J_r\\) is the set of arcs with\n\\(M_r\\) value.\n\\(J_r^0\\) is the set of arcs with\n\\(M_r-1\\) value, \\(J_r^{-1}\\) plus \\(J_r\\) .\n\\(J_r^0 = J_r^{-1} \\cup J_r\\)\nStep 4:\nAssign \\(\\infty\\) as the cost of all\narcs in \\(J_r^0\\)\nWe cut the arcs in \\(J_r^0\\) first,\nin order to re-calculate a suitable new path for the overflow nets.\nStep 5: Obtain \\(K_r\\) and \\(K_r^0\\)\n\\(K_r\\) is the set of nets with\narcs in \\(J_r\\) .\n\\(K_r^{-1}\\) is the set of nets\nwith arcs in \\(J_r^0\\) .\n\\(K_r^0 = K_r^{-1} \\cup K_r\\)\nStep\n6: Re-compute the shortest path for all nets in \\(K_r\\) with new cost(Some arcs are \\(\\infty\\) )\nFind new path for the overflow nets.\nStep 7-1: We\nfind some nets with non- \\(\\infty\\)\ncost.\n\\(k_0\\) is the net with the minimum\ncost increase between old and the new routes.\nAlthough we find a new route path, we still want the routing cost to\nbe minimized.\n\nStep\n7-2: All nets are \\(\\infty\\) cost.\n(Maybe unsolvable or need to rip up the nets)\nIf we only use 1 arc or 0 arc in the whole network for the net \\(k \\in K_r^0\\) .\nIt means that we cannot route this graph. It do not have a\nsolution.\n\nelse, we find the net \\(k' \\in\nK_r^0\\) will the maximum number of arcs in \\(J_r^0\\) .\nRip up \\(k'\\) and reroute\nit.\nAdd to the last iteration’s solution and go back to Step 1.\n\nStep\n8: Construct the new routing solution by change the net \\(k_0\\) with new routing path only.\nWe will use the old routing solution from the last iteration except\nfor the net \\(k_0\\) .\nStep\n9: Back to Step 1, until the maximum overflow \\(\\leq 0\\) .\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2020/09/06/08/00/red-thread-5548304_960_720.jpg",
    "last_modified": "2022-05-19T23:15:38+08:00",
    "input_file": {}
  },
  {
    "path": "eda/steiner-min-max-tree-algorithm/",
    "title": "Steiner Min-Max Tree Algorithm",
    "description": "Note for EDA routing algorithm - Steiner Min-Max Tree Algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-05-15",
    "categories": [
      "EDA",
      "routing",
      "CAD"
    ],
    "contents": "\n\nContents\nSMMT(Steiner Min-Max\nTree Algorithm)\nWhat is the meaning of\nedge?\nAlgorithm\nSMMT phase\nSP phase\n\n\nSMMT(Steiner Min-Max Tree\nAlgorithm)\nminimized the maximum sum of edge in the tree.\n\\(\\min (\\max \\sum_{edge e \\in T}\nw(e))\\)\nWhat is the meaning of edge?\nHow many nets are overlapping on this edge?\nImporve routability\nMinimize congestion\nWe can use ALG-SMMT\nalgorithm to solve optimal SMMT problem(Not NP-hard problem). If we want\nto minimized the wire length of SMMT tree, that is called MSMMT problem,\nwhich is NP-hard problem.\nAlgorithm\nWe will sequantially route the nets and the nets order is important\nfor the result.\nWe will use HPBB(half-perimeter of the bounding box) as our\nestimation of wire length.\nWe will use the HPBB value as nets in increasing order.\nSMMT phase\nfor each net \\(n\\) in the order\nabove\nUse ALG-SMMT to build a MST from graph \\(G\\)\nRemove the vertex, which match both condition below, and it will\nbecome a Steiner tree \\(ST'\\)\nvertex with degree 1.\nNon-terminal vertex.(The vertex which is not the node in nets).\n\nCheck the wirelength of \\(ST'\\)\nfor this net, if:\n\\(< threshold\\) , accept\nit!\n\\(> threshold\\) , reject it!\ndon’t add this tree into the final result.\n\\(threshold = \\text{unit cost per wire\nlength} \\cdot HPBB(n)\\)\n\n\nWe can execute this pass multiple times or just 1 time.\nSP phase\nfor each net \\(n\\) in the order\nabove (same as SMMT phase):\nRemove the steiner tree of \\(n\\)\nfrom the graph \\(G\\) and also remove\nthe occupied capacity from each edge.\nUse ALG-SP algorithm to re-route the graph \\(G\\) in order to minimize the wirelength.\nThe center of SP tree is the vertex, which is the closest to the\ngeometric center of the bounding box of \\(n\\) .\n\nCheck the routing result, it should obey the edge capacity\nconstraint.\nCheck the wire length, if :\nmax weight edge reduced, accept it!, or\nwire length reduced, accept it!\nIf reject, just use previous result.\n\n\nWe can execute this pass multiple times or just 1 time.\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2020/09/06/08/00/red-thread-5548304_960_720.jpg",
    "last_modified": "2022-05-15T21:25:21+08:00",
    "input_file": {}
  },
  {
    "path": "eda/elmore-routing-tree-algorithm/",
    "title": "Elmore Routing Tree Algorithm",
    "description": "Note for EDA routing algorithm - Elmore Routing Tree Algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-05-05",
    "categories": [
      "EDA",
      "routing",
      "CAD"
    ],
    "contents": "\n\nContents\nElmore delay\nElmore Routing Tree\nAlgorithm\nSteiner Elmore\nRouting Tree Algorithm\n\n\nSimilar to Bounded Radius\nRouting Algorithm and 1-Steiner Routing\nAlgorithm.\nBut different in how to select a good node for prim’s MST\nalgorithm\nElmore delay\n\\(t_{elmore}(n_i) = r_d \\cdot C_{n_0} +\n\\sum_{e_v \\in path(n_0, n_i)}\nr_{e_v}(\\frac{c_{e_v}}{2}+C_v)\\)\n\\(r_d\\) is the output\nresistance\n\\(C_{n_i}\\) is the total\ncapacitance of a subtree of \\(T\\)\nrooted at \\(n_i\\)\n\\(e_v\\) is the edge between vertex\n\\(v\\) and its parent.\n\\(r_{e_v}\\) and \\(c_{e_v}\\) are calculated by the problem\nparameter. \\(\\Omega / m(wire length)\\)\nand \\(F / m(wire length)\\)\nElmore Routing Tree\nAlgorithm\nselect phase:\nfor node \\(v\\) in \\(MST\\) :\nfind the nearest node \\(u\\) of\n\\(v\\)\nCalculate the elmore delay for \\(u\\)\n\nchoose the lowest elmore delay node as the next included node.\nSteiner Elmore Routing\nTree Algorithm\nselect phase:\nfor node \\(v\\) in \\(MST\\) :\nfind the nearest node \\(u\\) of\n\\(v\\) and try to add steiner\npoint between u and v\nCalculate the elmore delay for \\(u\\)\nOr connect \\(u\\) and \\(s\\)(source) node and calculate the elmore\ndelay.\n\nchoose the lowest elmore delay node as the next included node.\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2020/09/06/08/00/red-thread-5548304_960_720.jpg",
    "last_modified": "2022-05-06T09:50:01+08:00",
    "input_file": {}
  },
  {
    "path": "eda/a-tree-algorithm/",
    "title": "A-tree Algorithm",
    "description": "Note for EDA routing algorithm - A-tree Algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-05-03",
    "categories": [
      "EDA",
      "routing",
      "CAD"
    ],
    "contents": "\n\nContents\nMSP-SA and MRSA\nGoal\nAlgorithm\nPartition\nthe neighboring nodes of every node \\(p\\)\n3 value( \\(dx,\ndy, df\\) )\n3 safe moves\nT1\nT2\nT3\n\nProcessing\n\n\nMSP-SA and MRSA\nMSP-SA is Minimum shortest path steiner arborescence.\nMRSA is rectilinear version of MSP-SA. Minimum Rectilinear steiner\narborescence.\nGoal\nUse A-tree Algorithm to solve MRSA problem.\nMinimize the overall wire length.\nAlso maintaining the shortest linear path length from source to all\nsink node.\nAlgorithm\nPartition the\nneighboring nodes of every node \\(p\\)\nnodes in \\(NW(p), SE(P)\\) or\n\\(D(p, F_k)\\) are root node!\nhttps://i.imgur.com/1TMlxqZ.jpg\nhttps://i.imgur.com/tg3K7Lo.jpg\n3 value( \\(dx, dy,\ndf\\) )\n\\(dx\\) is the minimum horizontal\ndistance from \\(p\\) to the node in\n\\(NW(p)\\) , which isn’t blocked by\n\\(p\\)\n沒被 block的root node 且與 \\(p\\)\n最短水平距離\n\n\\(dy\\) is the minimum vertical\ndistance from \\(p\\) to the node in\n\\(SE(p)\\) , which isn’t blocked by\n\\(p\\)\n沒被 block的root node 且與 \\(p\\)\n最短垂直距離\n\n\\(dy\\) is the minimum rectilinear\ndistance from \\(p\\) to the node in\n\\(D(p, F_k)\\) . nodes here don’t need\nto be root nodes.\n\\(mf_w\\) is the node with minimum\nx-coordinate.\n\\(mf_s\\) is the node with minimum\ny-coordinate.\n與 \\(p\\) 有最短 rectilinear 距離的\nnode (不一定要是 root node)\n\n3 safe moves\nT1\n\\(dx \\ge df\\) and \\(dy \\ge df\\) . It means that we will only\nuse nodes in \\(D(p,F_k)\\)\nAdd a path that connect \\(p\\) and\n\\(mf_w\\) .\nRemove \\(p\\) from root node\nlist.\nT2\n\\(dx \\ge df\\) and \\(dy < df\\) . It means that we may use\nnode in \\(SE(p)\\) or \\(D(p, F_k)\\)\nAdd down-ward vertical path of length \\(p'\\) and that point is a steiner point.\n\\(p' = \\min (d(p, mf_s),\ndy)\\)\n\nRemove \\(p\\) from root node list\nand add node \\(p'\\) into root node\nlist.\nT3\n\\(dx < df\\) and \\(dy \\ge df\\) . It means that we may use node\nin \\(NW(p)\\) or \\(D(p, F_k)\\)\nAdd left-ward vertical path of length \\(p'\\) and that point is a steiner point.\n\\(p' = \\min (d(p, mf_w),\ndx)\\)\n\nRemove \\(p\\) from root node list\nand add node \\(p'\\) into root node\nlist.\nProcessing\nStart with an initial forest \\(F_0\\) , which is construct by all\nnode.\nthen a sequence of moves, which are growing(T2, T3) or merging(T1),\nare performed.\nAfter each move, we will need to recalculate the \\(dx, dy, df\\) value.\n\nAt the end, there will remain only 1 tree and we done.\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2020/09/06/08/00/red-thread-5548304_960_720.jpg",
    "last_modified": "2022-05-03T10:10:24+08:00",
    "input_file": {}
  },
  {
    "path": "eda/bounded-radius-routing-algorithm/",
    "title": "Bounded Radius Routing Algorithm",
    "description": "Note for EDA routing algorithm - Bounded Radius Routing Algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-04-25",
    "categories": [
      "EDA",
      "routing",
      "CAD"
    ],
    "contents": "\n\nContents\nBPRIM(Bounded Prim)\nBRBC(Bounded Radius\nBounded Cost)\n\nHow to construct MST with bounded radius or bounded wire length for\nL-Shaped\nSteiner Routing Algorithm? We called it bounded radius MST.\nBPRIM(Bounded Prim)\nInitialize MST \\(T\\) with source\nnode \\(s\\) .\n\\(R\\) is the longest distance from\n\\(s\\) to the other node in \\(P\\) .\nfor each node \\(v\\) , which is the\nclosest neighbor to \\(T\\) and \\(v \\notin T\\)\nThe closest node with \\(v\\) is\n\\(y\\) , where \\(v \\notin T, y \\in T\\) .\ncheck \\(dist_T(s, v) + dist(v, y) \\leq (1\n+ \\epsilon)R\\) , where \\(\\epsilon\\) is user\nYes, add edge \\((v, y)\\) into \\(T\\) .\nNo, Find some node \\(v' \\in T\\)\nsuch that \\(dist_T(s, v') + dist(v' +\ny) \\leq R\\)\n\n\nBRBC(Bounded Radius Bounded\nCost)\nConstruct initial MST \\(Q\\)\nMake MST \\(Q\\) became a rooted tree\n\\(T_s\\)\nThe order of Depth-first search on \\(T_s\\) is \\(L\\)\nfor each \\(v \\in L\\) with ordered\niterating\ncheck \\(\\epsilon \\cdot dist(s, v) \\leq\nS\\) , where \\(S\\) is the\naccumulated cost of the path from the latest check point.\nYes!\nSet \\(S\\) became \\(0\\)\nthe start point of the calculation of \\(S\\) became \\(v\\) .\nAdd edge \\((s, v)\\) into \\(Q\\) .\n\nNo! do nothing.\n\nConstruct the shortest path tree on \\(Q\\) and it will become BR-MST.\nFind the shortest path from \\(s\\)\nto the other point and it is the shortest path tree.\n\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2020/09/06/08/00/red-thread-5548304_960_720.jpg",
    "last_modified": "2022-04-25T15:43:57+08:00",
    "input_file": {}
  },
  {
    "path": "eda/1-steiner-routing-algorithm/",
    "title": "1-Steiner Routing Algorithm",
    "description": "Note for EDA routing algorithm - 1-Steiner Routing Algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-04-21",
    "categories": [
      "EDA",
      "routing",
      "CAD"
    ],
    "contents": "\n\nContents\nNaive method\nHeuristic method\n\nGiven a MST with point set \\(P\\) ,\ndenoted \\(MST(P)\\) .\nFind one additional Steiner point \\(s\\) so that the wire length of \\(MST(P \\cup s)\\) is shorter than \\(MST(P)\\) .\nNaive method\nFind all possible 1-steiner points \\(P\\) by Hanan grid\nFor each 1-steiner points \\(s \\in\nP\\) , construct \\(MST(P \\cup\ns)\\) .\nFind the MST with shortest wirelength.\n\nrepeat above until no improvement.\nHeuristic method\nUse \\(\\textrm{gain}\\) to decide\nwhere to add steiner point.\npicture from book practical problems in\nVLSI physical design automation\n\\(\\textrm{gain}(p, e) =\n\\textrm{length}(e_2) - \\textrm{length}(p, p_1)\\)\n\\(p \\in P\\) , \\(e \\in MST(P)\\)\n\\(e_2\\) is the longest edge from\n\\(p\\) to edge \\(e\\) .\n\\(p_1\\) is the steiner point on\nhanan grid.\n\nfor each edge \\(e \\in\nMST(P)\\)\nFind the largest \\(\\textrm{gain}\\)\nvalue\nSort descending as \\(E\\) .\n\nfor each \\(g \\in E\\)\n\\(g = \\textrm{gain}(p, e)\\)\nremove corresponding \\(e_2\\) , and\nconnect \\(p\\) and \\(p_1\\) .\nIf edge \\(e\\) were removed by\nprevious operation, just skip it.\n\nrepeat above until no improvement.\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2020/09/06/08/00/red-thread-5548304_960_720.jpg",
    "last_modified": "2022-04-21T21:48:22+08:00",
    "input_file": {}
  },
  {
    "path": "eda/l-shaped-steiner-routing-algorithm/",
    "title": "L-shaped Steiner Routing Algorithm",
    "description": "Note for EDA routing algorithm - L-shaped Steiner Routing Algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-04-21",
    "categories": [
      "EDA",
      "routing",
      "CAD"
    ],
    "contents": "\n\nContents\nPrerequisite\nGoal\nAlgorithm\nConstruct minimum\nspanning tree\nDetermine\nthe shape of each edge(upper L or lower L) by DP in bottom-up\nfashion\nBrute force all possible\ncase\nVisit\nthe tree in top-down fashion to construct the steiner tree\n\n\nsolve the RST (Rectilinear Steiner Tree) problem by constructing a\nR-MST (Rectilinear Minimum Spanning Tree) and refine it.\nPrerequisite\n\\(cost(\\forall RMST) \\leq\n1.5cost(\\text{optimal } RST)\\)\nUse prim or kruskal algorithm to construct the minimum spanning\ntree.\nGoal\nMaximize the number of overlapping edges.\nAlgorithm\nhttps://i.imgur.com/f1FDkYj.pngConstruct minimum spanning\ntree\n\\(\\textrm{weight}(i, j) = (D(i, j), -|y(i)\n- y(j)|, -\\max\\{x(i), x(j)\\})\\)\nWe want to find the shortest edges, larger vertical distance and\nrightmost vertices.\nDetermine\nthe shape of each edge(upper L or lower L) by DP in bottom-up\nfashion\nCalculate \\(\\Phi_\\ell(v)\\) and\n\\(\\Phi_u(v)\\)\n\\(\\Phi_\\ell(v)\\) means the number\nof overlapping edge when \\(e_v\\) is\nlower L.\n\\(\\Phi_u(v)\\) means the number of\noverlapping edge when \\(e_v\\) is upper\nL.\nBrute force all possible\ncase\n\\(\\Phi_{\\ell \\text{ or } u}(v) = \\max(Z_1\n+ Z_2)\\)\n\\(Z_1 =\\) overlap in all of edges\nincident to \\(v\\)\nCalculate the overlapping of \\(e_v\\) with all the combinations of the\nchildren of \\(v\\) (lower or upper\nL)\n\n\\(Z_2 =\\) overlap in the children\nof \\(v\\)\nSum up the corresponding combination’s \\(\\Phi_\\ell(k)\\) or \\(\\Phi_u(k)\\) , \\(k\\) is the children of \\(v\\)\n\n\nVisit\nthe tree in top-down fashion to construct the steiner tree\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2020/09/06/08/00/red-thread-5548304_960_720.jpg",
    "last_modified": "2022-04-21T21:48:48+08:00",
    "input_file": {}
  },
  {
    "path": "eda/timberwolf-algorithm/",
    "title": "TimberWolf algorithm",
    "description": "Note for EDA placement algorithm - TimberWolf algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-31",
    "categories": [
      "EDA",
      "placement",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nAlgorithm\nState\nCost function\nDelta of cost function\n\nOverlapping causing by\nexchanging\n\n\noriginal\npaper\nGoal\nGlobal and detail standard cell placement.\nAlgorithm\nUsing Simulate\nAnnealing algorithm\nState\nrandom initial placement or wiring configuration\nnew state is generated by\nSwap: exchanging 2 fundamental units\n(big, small) -> (small, big)\nbig -> small will cause overlap. shift it!(to the less shift\namount side)\nsmall -> big will make some small gap. do nothing. (It will be\nused for the later shift for the big block)\n\nMove: moving a unit to another row\nMirror: Reflect the cell orientation around the y-axis\n#EDAproblem\n\nCost function\ntotal estimated wire length\nhalf-perimeter of the bounding box of the net.\nDelta of cost function\n\\(\\Delta C = \\Delta W + \\Delta\nW_s\\)\n\\(\\Delta W\\) is the wire length\nchange due to new state. (real result)\nCalculate the effected nets’ change.\n\n\\(\\Delta W_s\\) is the wire length\nchange due to shifting the cells to remove the overlap. (estimated\nresult)\nestimated the \\(\\Delta W_s\\) by gradient\nFind the nets, which contain the shifted block, and find the left\nand right boundary.\nIf the shifted block is on the right boundary, the gradient\nshould increase.\nIf the shifted block is on the left boundary, the gradient should\ndecrease.\nelse, gradient remain unchange.\n\\(\\Delta W_s = \\sum_{j \\in\nshifted\\_cell} gradient(j) \\cdot shift\\_amount(j)\\)\nOverlapping causing by\nexchanging\nUse penalty function #EDAproblem\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2018/03/13/22/53/puzzle-3223941_960_720.jpg",
    "last_modified": "2022-04-21T22:00:13+08:00",
    "input_file": {}
  },
  {
    "path": "eda/gordian-algorithm/",
    "title": "GORDIAN algorithm",
    "description": "Note for EDA placement algorithm - GORDIAN algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-23",
    "categories": [
      "EDA",
      "placement",
      "CAD"
    ],
    "contents": "\n\nContents\nMath\nAlgorithm\n\nUse analytical method and linear programming video\nMath\nGoal is to minimize the total square of wire length\nthe sum of square wire length between each moveable\nnodes(gates).\nthe sum of square wire length between moveable nodes(gates) and\nfixed nodes(pin).\n\nObjective function(minimize it)\nx axis : \\(\\frac{1}{2}x^TLx +\nd_x^Tx\\)\ny axis : \\(\\frac{1}{2}y^TLy +\nd_y^Ty\\)\n\nAlgorithm\nConstruct the k-clique graph for each net\nthe weight will be \\(\\frac{2}{k}\\)\n\nBuild the laplacian matrix and write down the objective\nfunction\niterative optimize it\nfor the first time\nminimize without any constraint\n\nfor the other time\nminimize with balance factor \\(\\alpha\\)\nminimize objective function above and constraint\ncenter of gravity constraint\nthe center of gravity of nodes in separated part should match the\ncenter of gravity constraint\n\n\n\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2018/03/13/22/53/puzzle-3223941_960_720.jpg",
    "last_modified": "2022-03-27T23:05:16+08:00",
    "input_file": {}
  },
  {
    "path": "eda/mincut-placement/",
    "title": "Mincut placement with propagation ",
    "description": "Note for EDA placement algorithm - Mincut placement with propagation",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-20",
    "categories": [
      "EDA",
      "placement",
      "CAD"
    ],
    "contents": "\n\nContents\nMincut placement\nTerminal propagation\n\nMincut placement\nRepeatedly split the circuit into sub-circuits by [[Partitioning]]\nalgorithm.\nUntil each partition only occupied by a single gates (or sometimes\nspecial sub-circuits).\nTerminal propagation\nDuring the first partition, there are some cases that two gate\n\\(x\\) and \\(y\\) is in the adjacent block.(wire length =\n1)\nBut at the second partition, we tried to partition the block of\n\\(x\\) and make \\(x\\) away from \\(y\\) (wire length = 2)\nWe need to connect the \\(x\\) and\n\\(y\\) to prevent the additional wire\nlength.\nhttps://i.imgur.com/1oIpQof.png\\(m\\) and \\(i\\) should be in the same partition and at\nthe left most side, otherwise we need more wire length.\n\n",
    "preview": "https://cdn.pixabay.com/photo/2018/03/13/22/53/puzzle-3223941_960_720.jpg",
    "last_modified": "2022-03-27T23:05:20+08:00",
    "input_file": {}
  },
  {
    "path": "eda/ilp-floorplanning-algorithm/",
    "title": "ILP floorplanning algorithm ",
    "description": "Note for EDA floorplanning algorithm - ILP floorplanning algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-17",
    "categories": [
      "EDA",
      "floorplanning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nIdea\nAlgorithm\nFor flexible module\nProblem\n\nGoal\nGiven some module with width and height, and some constraint(eg.\nrotation or not .etc), output the minimize(eg. area .etc)\nfloorplanning.\nSuitable for fixed and flexible module.\nIdea\nThere are so many constraint(eg. module size, rotation or not .etc)\nand one objective function(minimize floorplanning) to optimize.\nUse Integer Linear programming to solve it!!\nOnly consider the integer solution by branch and bound. video\n\nAlgorithm\nObjective function: minimize \\(y^*\\) , it is the width of total chip\nsize(square chip here).\nUse \\((x_{ij}, y_{ij})\\) pair to\ndefine the location relationship of module \\(i\\) and \\(j\\) .\nUse \\(z_i\\) to mark rotation or\nnot. \\(z_i = 0\\) mean we will NOT\nrotation the module \\(i\\) .\nNon-overlapping constraint\nWrite down each pair of module and avoid the overlapping. Below is\none of the example.\n\n\nVariable constraint\nSize of module should positive.\nrelationship variable should be binary.\n\n\nChip width constraint\n\n\nChip height constraint\n\n\nFor flexible module\nConstraint style is same as above.\nSince the width and height of flexible module can be changed, only\narea and aspect ratio is given, We want to obtain the\nLinear relationship between height and width.\nUse Taylor\nexpansion!\n\\(hw = S\\) , \\(S\\) is the area.\n\\(h = \\frac{S}{w} = \\frac{S}{w_{max}} +\n(w_{max} - w)\\frac{S}{w_{max}^2} + \\dots\\)\nUse more term can obtain more accuracy.\n\n\nProblem\nFor flexible module, we use taylor expansion to approximate the\nrelationship between width and height.\nSince it is approximate value, we will have some error value\nthere.\nSolution: Use more term to get high quality answer.\n\n",
    "preview": "https://cdn.pixabay.com/photo/2016/11/24/20/30/architecture-1857175_960_720.jpg",
    "last_modified": "2022-03-27T23:03:14+08:00",
    "input_file": {}
  },
  {
    "path": "eda/normalized-polish-expression/",
    "title": "Normalized Polish Expression ",
    "description": "Note for EDA floorplanning algorithm - Normalized Polish Expression",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-16",
    "categories": [
      "EDA",
      "floorplanning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nProperty of\nnormalized polish expression\nIdea\nAlgorithm\nProblem\n\nGoal\nGiven the polish expression of a slicing tree, output the minimum\nsize of floor planning.\n\\(PE = 25V 1H374V H6V 8V H\\)\n\nProperty of normalized\npolish expression\nEach block(operand) appears exactly once in the string. (eg. only\none 2 or 5 in the string)\nBalloting property\nThe number of operands is larger than the number of operators\n\nNormality property\nNo consecutive operators of the same type in the string\n1-1 correspondence to a slicing tree. (NPE can obtain an unique\nslicing tree)\n\nIdea\nUse Simulate Annealing algorithm\nWhat is the neighbor of the current polish expression?\n\\(Move_1\\) : Swap adjacent\noperands.\neg. 25V -> 52V or 374V -> 734V\n\n\\(Move_2\\) : Swap two operators.\neg. 25V1H -> 25H1V\n\n\\(Move_3\\) : Swap adjacent operand\nand operator.\neg. 6V8V -> V68V\nNOTICE!! need to keep the Balloting property and Normality property\n.\n\n\nAlgorithm\nRandom polish expression \\(PE_0\\)\nParameters for Simulate Annealing algorithm\n\\(T_0\\) and \\(T_{end}\\)\nCooling rate \\(\\alpha\\)\nNumber of move at each temperature \\(M_t\\)\n\n\\(Z\\) is the optimal answer that we\ncurrently have\nFor \\(i\\) in each temperature\nPerform one of the three type of move above \\(PE_i'\\)\n\\(C_i = A_i + \\lambda \\cdot W_i\\)\n\\(C_i\\) is the cost of \\(PE_i'\\)\n\\(A_i\\) is the area of \\(PE_i'\\)\n\\(\\lambda\\) is a\nhyperparameter\n\\(W_i\\) is the wirelength of \\(PE_i'\\)\n\n\\(\\Delta C = C_i - C_{i-1}\\)\nDecide whether to accept this proposal\nIf \\(\\Delta C > 0\\)\nAccept this change\n\nelse\nCalculate the probability \\(p = exp(\\Delta\nC / T_i)\\)\nIf \\(p > rand(0, 1)\\)\nAccept this change\n\nelse\nReject this change\n\n\n\nUpdate the temperature\n\\(T = \\alpha T\\)\n\n\nProblem\nHow to generate the initial slicing tree input?\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2016/11/24/20/30/architecture-1857175_960_720.jpg",
    "last_modified": "2022-03-27T23:02:34+08:00",
    "input_file": {}
  },
  {
    "path": "eda/stockmeyer-algorithm/",
    "title": "Stockmeyer algorithm ",
    "description": "Note for EDA floorplanning algorithm - Stockmeyer algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-15",
    "categories": [
      "EDA",
      "floorplanning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nIdea\nAlgorithm\nProblem\n\nGoal\nGiven a slicing tree, output the minimum size of floor\nplanning.\n\nIdea\nFor 2 child with dimension \\((h_l,\nw_l)\\) and \\((h_r, w_r)\\)\nFor vertical node(eg. 1, 5 in the figure above)\n\\(D = (width_1 + width_2, max(height_1,\nheight_2))\\)\n\nFor horizontal node(eg. 2, 8 in the figure above)\n\\(D = (max(width_1, width_2), height_1 +\nheight_2)\\)\n\nAlgorithm\nObjective\nLeft child with dimension \\((h_l,\nw_l)\\)\nRight child with dimension \\((h_r,\nw_r)\\)\nList \\(L = \\{(h_l, w_l), (w_l,\nh_l)\\}\\) sort by the first or second element.\nList \\(R = \\{(h_l, w_l), (w_l,\nh_l)\\}\\) sort by the first or second element.\n\nFor vertical node\n\\(L, R\\) sort by the first\nelement\nLike merge two sorted list\n\\(l = l_1, r = r_1\\)\nif \\(l.second > r.second\\) ,\nthen \\(l = l_{next}\\)\nif \\(l.second < r.second\\) ,\nthen \\(r = r_{next}\\)\nif \\(l.second = r.second\\) , then\n\\(l = l_{next}, r = r_{next}\\)\n\nIt will generate a dimension list \\(D\\) contain multiple dimension\ncombination.\nWith \\(D = (width_1 + width_2,\nmax(height_1, height_2))\\)\n\nFor horizontal node\nLike above, but with \\(D = (max(width_1,\nwidth_2), height_1 + height_2)\\)\nLike merge two sorted list\n\\(l = l_1, r = r_1\\)\nif \\(l.first > r.first\\) , then\n\\(l = l_{next}\\)\nif \\(l.first < r.first\\) , then\n\\(r = r_{next}\\)\nif \\(l.first = r.first\\) , then\n\\(l = l_{next}, r = r_{next}\\)\n\n\nNow we know the total floor planning area by bottom-up the slicing\ntree.\nTo get the location of each node in the slicing tree, traverse the\nslicing tree top-down.\nProblem\nHow to generate the initial slicing tree input?\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2016/11/24/20/30/architecture-1857175_960_720.jpg",
    "last_modified": "2022-03-27T23:02:58+08:00",
    "input_file": {}
  },
  {
    "path": "eda/fbb-algorithm/",
    "title": "FBB algorithm ",
    "description": "Note for EDA partitioning algorithm - FBB algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-14",
    "categories": [
      "EDA",
      "partitioning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nRe-construct the flow\nnetwork\nIteratively\ncall the maximum-flow algorithm\n\nGoal\nBalanced bipartition.\ndivided the circuit into 2 equal-sized partitions.\nRe-construct the flow\nnetwork\nTurn the original circuit into bi-directed graph\nhttps://i.imgur.com/xbvXKhs.pngfor each net \\(n\\) (hyperedge)\nadd vertices into graph \\(G\\)\nadd two auxiliary nodes \\(n_1\\) and\n\\(n_2\\) into the graph \\(G\\) with edge of capacity \\(0\\)\nconnect the vertices into \\(n_1\\)\nand \\(n_2\\) into all the vertices with\nedge of capacity \\(\\infty\\)\n\n\nIteratively call\nthe maximum-flow algorithm\nRandomly select 2 vertices as \\(s\\)\nand \\(t\\) for maximum-flow\nalgorithm.\nFound the augmenting path \\(AG\\)\n(maybe multiple paths)\nThere are some net \\(n\\) in the\n\\(AG\\) , check whether it will\nconstruct the balanced partition.\nYes\nWe found the partition with cut size equals to the maximum flow\nvalue.\n\nNo, We got a cut \\(C(X, X')\\)\nif \\(|X|\\) has less vertices, merge\nthe random vertices in \\(X'\\) into\nvertex \\(s\\) , vice versa.\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2017/07/13/19/30/texture-2501600_960_720.jpg",
    "last_modified": "2022-04-25T15:49:39+08:00",
    "input_file": {}
  },
  {
    "path": "eda/eig-algorithm/",
    "title": "EIG algorithm",
    "description": "Note for EDA partitioning algorithm - EIG algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-13",
    "categories": [
      "EDA",
      "partitioning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nLaplacian matrix \\(L\\) of graph \\(G\\)\n\\(\\lambda_2\\) optimization for symmetric\nmatrix\nAlgorithm\n\nGoal\nBalanced bipartition.\ndivided the circuit into 2 equal-sized partitions. # Graph in Linear\nalgebra\ngood\nexplanation\n\\(A\\) is adjacency matrix of\nundirected graph \\(G\\) .\n\\(x\\) is a vector and is a value of\neach node in \\(G\\) .\n\\(Ax = y\\) and what is the meaning\nof \\(y\\) ?\n\\(y_i = \\sum_{(i, j) \\in E(G)}\nx_j\\)\n\\(y_i\\) is the sum of the neighbor\nvalue of \\(x_i\\)\n\n\\(Ax = \\lambda x\\)\nSince \\(A\\) is symmetric matrix\n\\(\\rightarrow\\) eigenvector are real\nand orthogonal!\n\nLaplacian matrix \\(L\\) of graph \\(G\\)\n\\(D\\) is degree matrix.\n\\(D_{ii} =\\) degree of vertex \\(v_i\\) .\n\\(D_{ij} = 0, i \\neq j\\)\n\n\\(L = D-A\\)\n\\(L's\\) trivial eigenpair\n$ [1, , 1] ^T $\nwith \\(\\lambda = 0\\)\n\n\n\\(\\lambda_2\\) optimization for symmetric\nmatrix\n\\(\\lambda_2 = min_x\n\\frac{x^TLx}{x^Tx}\\)\nThe meaning of \\(x^TLx\\)\n\\(x^TLx = \\sum_{i, j = 1}^{n} L_{ij}x_jx_i\n= \\sum_{i, j = 1}^{n} (D_{ij} - A_{ij})x_jx_i =\\\\ \\sum_{i, j = 1}^{n}\nD_{ij}x_jx_i - \\sum_{i, j = 1}^{n} A_{ij}x_jx_i = \\\\ \\sum_{i= 1}^{n}\nD_{ii}x_i^2 - \\sum_{(i, j) \\in E(G)} 2x_jx_i = \\\\ \\sum_{(i, j) \\in E(G)}\nx_i^2 - 2x_jx_i + x_j^2 =\\\\ \\sum_{(i, j) \\in E(G)} (x_i -\nx_j)^2\\)\n\nProperty of \\(x\\)\n\\(x\\) is an unit vector \\(\\rightarrow \\sum_{i} x_i^2 = 1\\)\n\\(x\\) is orthogonal with 1st\neigenvector \\(\\rightarrow \\sum_i x_i =\n0\\)\n\nBack to \\(\\lambda_2 = min_x\n\\frac{x^TLx}{x^Tx} = min_x \\frac{\\sum_{(i, j) \\in E(G)} (x_i -\nx_j)^2}{\\sum_i x_i^2} =\\)\n\\(\\lambda_2 = min_x \\sum_{(i, j) \\in E(G)}\n(x_i - x_j)^2\\)\n\\(\\sum_{(i, j) \\in E(G)} (x_i -\nx_j)^2\\) means we don’t want to cross the group.\n\\(\\sum_i x_i = 0\\) means we need to\nbalance this two group.\n\n\nWe can use \\(0\\) or the median\nvalue of \\(x_i\\) to split the\ngroup.\nAlgorithm\nRe-calculate the graph\nfor each net \\(n\\) with size \\(k\\)\nconstruct the \\(k\\) -clique models\nwith weight of \\(\\frac{1}{k-1}\\)\nor we can use intersection graph.\n\n\nBuild the Laplacian matrix \\(L\\)\n\nCompute the second smallest eigenvalue and eigenvector \\(x\\) using [[Lanczos algorithm]].\n\nSort \\(x\\)\n\nUse sorted \\(x\\) to evaluate \\(n-1\\) partitioning solutions\n\\(((v_1), (v_2, \\dots, v_n))\\)\n\\(((v_1, v_2), (v_3, \\dots,\nv_n))\\)\nand so on\n\nCalculate each partition’s ratio cuts\nratio cut \\(= \\frac{c(X, Y)}{|X||Y|} =\n\\frac{\\text{cut size}}{\\text{size of X} \\times \\text{size of\nY}}\\)\n\nChoose partitioning with smallest ratio cut and balanced\npartition.\n\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2017/07/13/19/30/texture-2501600_960_720.jpg",
    "last_modified": "2022-03-27T23:00:36+08:00",
    "input_file": {}
  },
  {
    "path": "eda/fm-algorithm/",
    "title": "Fiduccia and Mattheyses algorithm (FM algorithm) ",
    "description": "Note for EDA partitioning algorithm -  Fiduccia and Mattheyses algorithm (FM algorithm)",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-10",
    "categories": [
      "EDA",
      "partitioning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nApplied directly on\nhypergraph\nBucket data structure\nIteratively\nmove(each iteration is called “pass”)\n\nCheck my C++ implementation here!\nGoal\nBalanced bipartition.\ndivided the circuit into 2 equal-sized partitions.\nApplied directly on\nhypergraph\nBucket data structure\nLike bucket sort, we first prepare some bucket to boost the sorting\nprocess.\nBucket size\nfrom \\(max(\\forall size(edge))\\) to\n\\(-max(\\forall size(edge))\\)\n\nIteratively\nmove(each iteration is called “pass”)\nRandomly bipartitioning the graph \\(G\\) with hyperedge\nDo procedure on the unmarked vertex until no\nunmarked exist\nFirst compute the gain value for all node.\n\\(x \\in P_1\\)\n\\(FS(x)\\) is the number of nets\nthat have \\(x\\) as the only cell in\n\\(P_1\\)\n\\(TE(x)\\) is the number of nets\nthat contain \\(x\\) and are entirely in\n\\(P_1\\)\n\\(gain(x) = FS(x) - TE(x)\\)\n\nmove the vertex \\(x\\) with maximum\nvalue of gain to the opposite under the area constraint, and then\nmark vertex \\(x\\)\nUse bucket to sort the maximum value.\narea constraint(after moving) : \\(|size(P_1) - size(P_2)| \\leq 1\\)\n\nre-compute the gain value of the unmarked neighbor\nvertex of \\(x\\) .\nRecord the \\(gain(x, y)\\) and the\ncurrent cut size\n\nIf the initial cut size has reduced during the current “pass”\nDo the other “pass” on the best solution\nOtherwise, terminate.\n\n",
    "preview": "https://cdn.pixabay.com/photo/2017/07/13/19/30/texture-2501600_960_720.jpg",
    "last_modified": "2022-05-19T23:33:09+08:00",
    "input_file": {}
  },
  {
    "path": "eda/kl-algorithm/",
    "title": "Kernighan and Lin algorithm (KL algorithm)",
    "description": "Note for EDA partitioning algorithm - Kernighan and Lin algorithm (KL algorithm)",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-03",
    "categories": [
      "EDA",
      "partitioning",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nRewrite\nthe original circuit graph into edge-weighted undirected graph \\(G\\)\nIteratively\nswap(each iteration is called “pass”)\n\nGoal\nBalanced bipartition.\ndivided the circuit into 2 equal-sized partitions.\nRewrite\nthe original circuit graph into edge-weighted undirected graph \\(G\\)\nRewrite the original circuit graph with hyper-edge, and it can share\nthe same node.\nEdge weight \\(c(x, y)\\) = \\(\\frac{1}{|e| - 1}\\) , where \\(e\\) is a hyper-edge and \\(|e|\\) is the size of that hyper-edge.\n\nIteratively\nswap(each iteration is called “pass”)\nRandomly bipartitioning the graph \\(G\\) (above rewritten graph)\nDo procedure on the unmarked vertex until no\nunmarked exist\nCompute all the possible swap pairs on the unmarked\nvertex.\nfor vertex \\(x \\in P_1\\) , we\ndefine:\n\\(E_x = \\sum_{i \\in P_2} c(x, i)\\)\nThis is the cut size of outward edge.\n\\(I_x = \\sum_{i \\in P_1} c(x, i)\\)\nThis is the cut size of inward edge.\n\nfor vertex \\(x \\in P_1, y \\in P_2\\)\n, if we swap them, the decrease of the cut size between \\(P_1\\) and \\(P_2\\) is :\n\\(gain(x, y) = (E_x - I_x - c(x, y)) +\n(E_y - I_y - c(x, y))\\)\n\n\nFind the pair with maximum \\(gain(x,\ny)\\) , swap \\((x, y)\\) , and\nthen mark vertex \\(x\\)\nand \\(y\\) .\nRecord the \\(gain(x, y)\\) and the\ncurrent cut size\n\nIf the initial cut size has reduced during the current “pass”\nDo the other “pass” on the best solution\nOtherwise, terminate.\n\n",
    "preview": "https://cdn.pixabay.com/photo/2017/07/13/19/30/texture-2501600_960_720.jpg",
    "last_modified": "2022-03-27T22:59:47+08:00",
    "input_file": {}
  },
  {
    "path": "eda/flowmap-algorithm/",
    "title": "FlowMap algorithm ",
    "description": "Note for EDA cluster algorithm - FlowMap algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-03-01",
    "categories": [
      "EDA",
      "clustering",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nAssumption\nUser constraint\nLabeling phase\nMapping phase\n\nFor the talk slide: link\nGoal\nTranslate the boolean network to K-input lookup table. (with input\npin constraint)\nFor FPGA K-input lookup table.\nThe maximum delay from PI to PO is minimized.\nAssumption\nDAG\neach node has a 0 delay\ninter-cluster has unit delay\nintra-cluster has 0 delay\nUser constraint\npin limit\nLabeling phase\nGet a topological sort : \\(T\\)\n(without PI)\n\\(l\\) is the delay.\neach node has a 0 delay\n\nFor each ordered node \\(t\\) ,\nconstruct graph \\(N_t\\) , which\ncontains all of the parent of \\(t\\) .\nthen add a source node \\(S\\) to \\(N_t\\) and connect it to all PIs node.\nCompute \\(p = max(l(\\forall \\text{fan-in\nnode of }t))\\)\nConstruct \\(N_t '\\) , where\n\\(l(v) = p, v \\in N_t\\) , \\(v\\) will be collapsed into \\(t\\) (同樣的 p值則縮點)\nConstruct a flow-network \\(N_t''\\) and duplicate the none-\n\\(s\\) and none- \\(t\\) node -> \\((x, x'), e(x, x') = 1\\) , the other\nedge are \\(\\infty\\)\nFind the cut \\(C(X'',\n\\bar{X''})\\) with cut size(number of edge in this cut)\n\\(\\leq\\) pin constraint\nIf found\n\\(cluster(t)\\) or in the paper\n\\(\\overline{X_t} = \\text{collapsed node and t}\n\\in N_t'\\)\n\\(l(t) = p\\)\n\nIf not found\n\\(cluster(t)\\) or in the paper\n\\(\\overline{X_t} = t\\)\n\\(l(t) = p + 1\\)\n\n\n\\(l_v = max(l_1, l_2)\\) (maximum\ndelay of node \\(v\\) with\ncluster size limit)\n\nMapping phase\nTry to combine some cluster.\nPut all PO nodes in a set \\(L\\)\nAnswer clusters will be in \\(S\\)\nFor each remove node \\(v\\) from\n\\(L\\)\nPush \\(cluster(v)\\) in to \\(S\\)\n\\(L = L \\cup input \\text{-}\nnode(cluster(v))\\) , where the node in \\(input \\text{-} node(cluster(v))\\) have not\nformed the cluster yet also not PI nodes(not in the answer set \\(S\\) yet).\n\nUntil \\(L\\) empty.\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2014/07/08/10/47/team-386673_960_720.jpg",
    "last_modified": "2022-04-24T11:31:14+08:00",
    "input_file": {}
  },
  {
    "path": "eda/rajaraman-and-wong-algorithm/",
    "title": "Rajaraman and Wong algorithm",
    "description": "Note for EDA cluster algorithm - Rajaraman and Wong algorithm",
    "author": [
      {
        "name": "Bo-Wei Chen",
        "url": "https://BWbwchen.github.io/"
      }
    ],
    "date": "2022-02-28",
    "categories": [
      "EDA",
      "clustering",
      "CAD"
    ],
    "contents": "\n\nContents\nGoal\nAssumption\nUser constraint\nLabeling phase\nClustering phase\n\nFor the talk slide: link\nGoal\nMaximum delay from PI(primary input) to PO(primary output) is\nminimized\nAssumption\nDAG\neach node has a unique delay\ninter-cluster has constant delay\nintra-cluster does not incur any delay\nUser constraint\nNode delay\nEdge delay\nCluster size limit\nLabeling phase\nCompute \\(\\Delta(x, v)\\) , which\nmeans the maximum delay from \\(x\\) to\n\\(v\\)\nGet a topological sort : \\(T\\)\n(without PI)\n\\(l\\) is the delay.\nPI node : 1\nnon-PI node initialize with 0\n\nFor each ordered node \\(v\\) ,\nconstruct graph \\(G_v\\) , which\ncontains all of the parent of \\(v\\)\nCompute \\(l_v(x)\\) , \\(x \\in G_v / {v}\\)\n\\(l_v(x) = l(x) + \\Delta(x, v)\\) (\nthe delay of path from PI to \\(x\\) then\nto \\(v\\) )\n\nSort \\(l_v(x)\\) in decreasing\norder: \\(S\\)\nPush the element one-by-one from \\(S\\) to \\(cluster(v)\\) with cluster size\nlimit\nComputer \\(l_1\\) (intra-cluster\ndelay) and \\(l_2\\) (inter-cluster\ndelay).\nIf \\(cluster(v)\\) contains any PI\nnodes\n\\(l_1 = max(l_v(\\forall PI \\text{ }\nnode))\\)\n\nIf size of \\(S\\) is bigger than\ncluster size limit\n\\(l_2 = max(l_v(\\forall x) + D), x \\in G_v\n/ v\\) , \\(D\\) is inter-cluster\ndelay.\n\n\n\\(l_v = max(l_1, l_2)\\) (maximum\ndelay of node \\(v\\) with\ncluster size limit)\n\nClustering phase\nTry to combine some cluster.\nPut all PO nodes in a set \\(L\\)\nAnswer clusters will be in \\(S\\)\nFor each remove node \\(v\\) from\n\\(L\\)\nPush \\(cluster(v)\\) in to \\(S\\)\n\\(L = L \\cup input \\text{-}\nnode(cluster(v))\\) , where the node in \\(input \\text{-} node(cluster(v))\\) have not\nformed the cluster yet(not in the answer set \\(S\\) yet).\n\nUntil \\(L\\) empty.\n\n\n\n",
    "preview": "https://cdn.pixabay.com/photo/2014/07/08/10/47/team-386673_960_720.jpg",
    "last_modified": "2022-04-18T23:53:55+08:00",
    "input_file": {}
  }
]
