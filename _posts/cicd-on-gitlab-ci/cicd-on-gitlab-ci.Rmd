---
title: "CI/CD on gitlab-ci"
description: |
  CI/CD on gitlab-ci with kubernetes

author:
  - name: Bo-Wei Chen
    url: https://BWbwchen.github.io/
date: 2021-08-08
output:
  distill::distill_article:
    toc: true
    toc_depth: 2
    self_contained: false
  toc_float: 
    collapsed: false
    smooth_scroll: true
draft: false
creative_commons: CC BY
editor_options: 
  markdown: 
    wrap: 72
categories:
  - CI/CD
  - docker
  - docker-compose
  - kubernetes
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

Recently, I have been writting a tinyURL service with a CI/CD pipeline on self-hosted gitlab. I want to record this horrible and time-consuming self-taught journey.

Our CI/CD pipeline will be composed with test, build and deploy. We first test the code, check whether there is any mistake in our code logic. Second, we build it to binary. Finally, we deploy our binary on the cloud or your own kubernetes.

## Environment
- golang 1.16.5
- docker 20.10.7
- docker-compose 1.29.2
- rancher 2.4.16
- gitlab-runner with docker executor

## tinyURL
tinyURL was written for self-taught with backend developement, kubernetes, docker and DevOps. User will give the service a longURL. Service will give back the short name of that URL. Once user query the service with the short name, service will need to give back the original long URL. for more info, check [this](https://github.com/BWbwchen/tinyURL)

This is the overview architecture:
![](/img/system_architecture.jpg#center)


## Test on Local
Notice that the whole system comprises 4 main module: api server, redis service, mongodb service and Zookeeper service. So I choose [`docker-compose`](https://docs.docker.com/compose/install/) to build a testing environment. Let's check the setting yaml file:
```yaml
version: "3"
services:
    server:
      container_name: myshorturl
      image: shorturl_test
      ports:
        - 8081:8081
      environment:
        REDIS_URL: redis:6379
        DB_URL: db:27017
        ZOOKEEPER_URL: zookeeper:2181
        PORT: 8081
      depends_on:
        - redis
        - db
        - zookeeper
    redis:
      container_name: redis
      image: redis:alpine
      expose:
        - 6379
    db:
      container_name: monogodb
      image: mongo:4.0.26-xenial
      expose:
        - 27017
    zookeeper:
      container_name: zookeeper
      image: zookeeper:3.7.0
      expose:
        - 2181
```
There are 3 things to notice:
1. Firstly, Make sure the version number is 3, or it will fail in the testing pipeline. 
2. Secondly, if api server want to connect with other service, connect the service name directly. eg: How to connect db ? just `<dbprotocol>://db`, such like : postgresql://db
3. Lastly, the difference between ports and expose. 
	- Ports will expose the port number and also **publish them to the host machine**. 
	- Expose will expose the port **between the containers**, it will not publish the port to the host machine.

Then run with command (it will shutdown containers automatically, if api-server finished test):
```shell
$ docker-compose up --abort-on-container-exit --exit-code-from server
```

## Test
```yaml
test-job:
  stage: test
  before_script:
    - apk add docker-compose
    - docker build -f Dockerfile-ci --tag shorturl_test .
  script:
    - docker-compose up --abort-on-container-exit --exit-code-from server
```
Since we use gitlab-runner docker executor with *`docker:stable`* image as default image, it only provide docker command. You can check the [official documentation](https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-the-docker-executor-with-the-docker-image-docker-in-docker). We need to install the docker-compose command for testing. use apk to install it. Then build a docker image for golang testing command.

```Dockerfile
# Dockerfile-ci
FROM golang:1.16
WORKDIR /app
COPY . .

CMD [ "go", "test", "-v" 
```

## Build
```yaml
build-job:  
  image: 
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  stage: build
  script:
     - mkdir -p /kaniko/.docker
     - echo "{\"auths\":{\"$DOCKER_REGISTRY\":{\"username\":\"${DOCKER_REGISTRY_USER}\",\"password\":\"${DOCKER_REGISTRY_PASSWORD}\"}}}" > /kaniko/.docker/config.json
     - /kaniko/executor --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/Dockerfile --destination $DOCKER_IMAGE
```
We use pre-build image to handle this stage.

## Deploy
Now, We will try to deploy our service on kubernetes. I use rancher for kubernetes.

There are some things need to sure.
1. kubeconfig file.
2. docker registry username, password

First, deploy a deployment on kubernetes. So we can automatically deploy the next job trigger.
```yaml
deploy-job:
  stage: deploy
  image: dtzar/helm-kubectl
  before_script:
    - sed -ie "s/deploy-date-value/$(date)/g" kubernetes/deploy.yaml
    - mkdir -p /root/.kube/ && touch /root/.kube/config
    - echo ${KUBERNETES_KUBE_CONFIG} | base64 -d > ${KUBECONFIG}
  script:
    - kubectl apply -f kubernetes/deploy.yaml
```
I use deply-date-value as a trigger to trigger the deployment update.

## Final
The CI/CD pipeline should run successfully ! Hooray ! ðŸŽ‰

If you have other problem, feel free to ask me !

You can find me here ðŸ‘‰ tim.chenbw@gmail.com