---
title: "Epoll study
"
description: |
  let's study about epoll, blocking and non-blocking
  
author:
  - name: Bo-Wei Chen
    url: https://BWbwchen.github.io/
date: 2021-08-13
output:
  distill::distill_article:
    toc: true
    toc_depth: 2
    self_contained: false
  toc_float: 
    collapsed: false
    smooth_scroll: true
draft: false
creative_commons: CC BY
editor_options: 
  markdown: 
    wrap: 72
categories:
  - epoll
  - tcp

---


# Blocking and Non-Blocking
When you send a request to server. Server will prepare some data for you (I/O operations). When you wait for data preparation, your program :
1. hang up the thread until the server finished the preparation and send response to you. (**Blocking**)
2. will get response immediately, but you probably got an error, if server hasn't finished the data preparation. Your program need to <mark>polling the server and checking error code of each request</mark>. But you are not blocked ! (**Non-Blocking**)

# Synchronous and Asynchronous
When you send a request to server. Server will prepare some data for you (I/O operations). When you wait for data preparation, your program :
1. hand up the thread until the server finished the preparation and send treponse to you. (**Synchronous**)
2. will get response immediately, but server will run your request in "backgroung". When server finished your request, it will <mark>notify you, or run the callback function</mark>. (**Asynchronous**)

## Non-Blocking I/O in C
Normally, you can't read or write directly to disk files. They usually do it via the kernel buffer cache as a proxy. But if you want to read or write directly, use **O_SYNC** flag when opening the disk file.

You can put any file descriptor in the nonblocking mode, just setting the no-delay flag **O_NONBLOCK**, which is an I/O operating mode, when opening the file.

## Readiness of Descriptors
We called it "ready". When a file descriptor can perform an I/O operation without blocking, such as the arrival of new input or sock connection establishment etc. There are 2 ways to find out the readiness of descriptors.

### Level Triggered (select, poll, epoll) (when the condition is met)
At any time, we "try to"(or poll for) perform an I/O operation on an non-blocking descriptor. If the I/O operation blocks, the system call returns an error. If the I/O operation ready, we can actually perform the entire I/O operation or just do nothing.

### Edge Triggered (Asynchronous) (when the status changed)
When the I/O operation is ready, it will notify the process or "PUSH" to the process. The process can attempt to perform the maximum operation it possibly can every time it get a descriptor readiness notification, or it will need to wait until next notification arrival.

But even with both 2 non-blocking methods, an extremely large read or write call has the potential to block.

### Select
level triggered mechanism.
```c
int select(
	int nfds, 
	fd_set *readfds, 
	fd_set *writefds,
	fd_set *exceptfds, 
	struct timeval *timeout
);
```
Select monitors 3 independent sets of descriptors. 
1. readfds, check if a read will not block
2. writedfs, check if a write will not block
3. exceptfds, monitored for exceptional conditions.

### Poll
But what if you want not just read, write or exceptional conditions ? Use poll ! we pass in a set of descriptors each marked event that it needs to track.
```c
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
struct pollfd {
	int   fd;         /* file descriptor */
	short events;     /* requested events */
	short revents;    /* returned events */
};
```

### Epoll (event poll)
Epoll instance is a kernel data structure. It allows for a process to monotor multiplex I/O on mltiple descriptors. You have 3 system call to control epoll instance :

#### epoll_create() 
```c
#include <sys/epoll.h>

int epoll_create(int size);
```
The size augrument, which is the number of descriptors, is ignored since Linux 2.6.8.
```c
#include <sys/epoll.h>

int epoll_create1(int flags);
```
flags can only be either 0 or EPOLL_COLEXEC.
1. flags is 0, it is the same as epoll_create(). 
1. flags is EPOLL_COLEXEC, it will set close-on-exec flag on the new file descriptor. 

#### epoll_ctl()
```c
#include <sys/epoll.h>

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```
It preformed **op** on target **fd** in **epfd** with **event**
##### op
1. EPOLL_CTL_ADD
2. EPOLL_CTL_MOD
3. EPOLL_CTL_DEL
##### events
```c
typedef union epoll_data {
	void        *ptr;
	int          fd;
	uint32_t     u32;
	uint64_t     u64;
} epoll_data_t;

struct epoll_event {
	uint32_t     events;      /* Epoll events */
	epoll_data_t data;        /* User data variable */
};
```
events is just a **bitmask** that indicates which events fd is being monitored for. For example:
```
EPOLLIN 	: The associated file is available for read operations.
EPOLLOUT 	: The associated file is available for write operations.
```
If you want to perform multiple events, just OR-ing them.
#### epoll_wait()
```c
#include <sys/epoll.h>
int epoll_wait(int epfd, struct epoll_event *eventlist,
				int maxevents, int timeout);
```
blocks until any descriptor being monitored become ready for I/O

## The bowels of epoll
#### In process
Let's first learn how the descriptor works. I create a file descriptor in process A, I will get a file descriptor. The system will store the descriptor and it's file pointer in a table in my process A. Every entry in this table has 2 fields :
1. descriptor flags.
2. file pointer, point to an underlying kernel open file table.
indexed by descriptor.

#### In kernel
Each file pointer point to an entry in kernel open file table. each entry in kernel open file table has 3 fields :
1. file offset
2. status flags
3. inode pointer.

#### In filesystem
Then each inode pointer point to an entry in filesystem  inode table. each entry in filesystem inode table has some fields :
1. file type.
2. file locks.
3. etc.

### How epoll works
process A call `epoll_create()` to create an epoll instance. The system will create an entry in kernel open file table, and it point to an entry in inode table. secondly, process A call `epoll_ctl()` to add a file descriptor `fd0` to the epoll instance's interset list. The system will point the `fd0` in epoll instance to `fd0` in kernel open file table (NOTICE: the kernel open file table entry is shared by referenced descriptor !!)
#### example
Consider the situation above, process A fork process B without close-on-exec, process B will have table as same as process B. for example, process A have fd0 and fork process B, it have a descriptor fd1. But fd0 and fd1 point to the same underlying kernel open file table entry.

#### Fork epoll
So same case, but the fd0 and fd1 in the above case is epoll descriptor. process A call `epoll_wait()`, after a moment it got notifications. But at the same time, process B will also got the notifications !!! 

So we can say once a file descriptor is registered by a process with the epoll instance, it will continue getting notifications about events on the descriptor even if it closes the descriptors as long as the underlying open file descriptor is still referenced by at least one descriptor.


### Performance
Select and poll are O(N) (or O(number of descriptors being monitored)), but epoll is O(1) (or O(number of events that have occurred)). Because every time the descriptor become ready, kernel will add it into the ready list in epoll instance. Once process call `epoll_wait()`, just return the ready list.
