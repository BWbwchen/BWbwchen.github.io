---
title: "Go interface for inheritance"
description: |
  CRUD with clean code by using Go embed struct

author:
  - name: Bo-Wei Chen
    url: https://BWbwchen.github.io/
date: 2021-08-07
output:
  distill::distill_article:
    toc: true
    toc_depth: 2
    self_contained: false
draft: false
creative_commons: CC BY
editor_options: 
  markdown: 
    wrap: 72
categories:
  - golang
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


Let's check this example :

```golang
type SQL struct {
	table SQL.table
}
```

We want CRUD (create, read, update, delete) operation. So you might write the code like this :

```golang
package main

import "fmt"

type SQL struct {
    table string
}

func (s SQL) Create () {
    fmt.Println("Create")
}
func (s SQL) Read () {
    fmt.Println("Read")
}
func (s SQL) Update (criteria string) {
    fmt.Println("Update", criteria)
}
func (s SQL) Delete (criteria string) {
    fmt.Println("Delete", criteria)
}

type ORM interface{
    Create()
    Read()
    Update(string)
    Delete(string)
}

func main() {
    sqldb := SQL{"table"}
    var db ORM = sqldb
    db.Create()
    db.Read()
    db.Update("record")
    db.Delete("table")
}
```
But you can notice that what if the operations were more than that ? We will get bunch of SQL member method ! We want to write "Clean Code". We should follow the ["Single-responsibility principle"(SRP)](https://www.wikiwand.com/en/Single-responsibility_principle) to design a more readable code. Struct SQL has deal with too many things ! We can try to make `Create` as a single struct, `Read` as a single struct. So each struct just do exactly one things. Let's try the concept of [`inheritance`](https://www.wikiwand.com/en/Inheritance_(object-oriented_programming))

Inheritance in Golang :
```golang
package main

import "fmt"

type SQL struct {
    table string
}

type CreateSql struct {
    SQL
}
func (c CreateSql) Operate () {
    fmt.Println("Create")
}

type ReadSql struct {
    SQL
}
func (s ReadSql) Operate () {
    fmt.Println("Read")
}

type UpdateSql struct {
    SQL
}
func (s UpdateSql) Operate (criteria string) {
    fmt.Println("Update", criteria)
}

type DeleteSql struct {
    SQL
}
func (s DeleteSql) Operate (criteria string) {
    fmt.Println("Delete", criteria)
}

type ReadOnlyORM interface{
    Operate()
}
type SideEffectORM interface{
    Operate(string)
}

func main() {
    dbCreate := CreateSql{SQL{"table"}}
    dbRead := ReadSql{SQL{"table"}}
    dbUpdate := UpdateSql{SQL{"table"}}
    dbDelete := DeleteSql{SQL{"table"}}

    var read_only_orm ReadOnlyORM
    read_only_orm = dbCreate
    read_only_orm.Operate()
    read_only_orm = dbRead
    read_only_orm.Operate()

    var side_effect_orm SideEffectORM
    side_effect_orm = dbUpdate
    side_effect_orm.Operate("test")
    side_effect_orm = dbDelete
    side_effect_orm.Operate("table")
}
```

Now we make each struct just do only one thing. If Update operation has Bug, we can just modified UpdateSql struct without affecting other method.

But it seems like bringing owls to Athens for such little program. Maybe it is a good method, when the code is larger, not just 60 lines.


